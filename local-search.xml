<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pdf笔记整理</title>
    <link href="/post/69424c74.html"/>
    <url>/post/69424c74.html</url>
    
    <content type="html"><![CDATA[<h1 id="PDF笔记整理"><a href="#PDF笔记整理" class="headerlink" title="PDF笔记整理"></a>PDF笔记整理</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="•-JavaSE学习笔记"><a href="#•-JavaSE学习笔记" class="headerlink" title="• JavaSE学习笔记"></a>• <a href="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/javase%E7%AC%94%E8%AE%B0.pdf">JavaSE学习笔记</a></h3><h3 id="•-Javaweb学习笔记"><a href="#•-Javaweb学习笔记" class="headerlink" title="• Javaweb学习笔记"></a>• <a href="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/javaWeb%E7%AC%94%E8%AE%B0.pdf">Javaweb学习笔记</a></h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="•-SSM框架学习笔记"><a href="#•-SSM框架学习笔记" class="headerlink" title="• SSM框架学习笔记"></a>• <a href="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SSM.pdf">SSM框架学习笔记</a></h3><h3 id="•-SpringBoot学习笔记"><a href="#•-SpringBoot学习笔记" class="headerlink" title="• SpringBoot学习笔记"></a>• <a href="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf">SpringBoot学习笔记</a></h3><h2 id="微服务技术"><a href="#微服务技术" class="headerlink" title="微服务技术"></a>微服务技术</h2><h3 id="•-微服务技术栈学习笔记"><a href="#•-微服务技术栈学习笔记" class="headerlink" title="• 微服务技术栈学习笔记"></a>• <a href="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf">微服务技术栈学习笔记</a></h3><h2 id="面试手册"><a href="#面试手册" class="headerlink" title="面试手册"></a>面试手册</h2><h3 id="•-Java开发面试手册"><a href="#•-Java开发面试手册" class="headerlink" title="• Java开发面试手册"></a>• <a href="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/Java%E5%BC%80%E5%8F%91.pdf">Java开发面试手册</a></h3><h2 id="项目学习笔记"><a href="#项目学习笔记" class="headerlink" title="项目学习笔记"></a>项目学习笔记</h2><h3 id="•-黑马瑞吉外卖学习"><a href="#•-黑马瑞吉外卖学习" class="headerlink" title="• 黑马瑞吉外卖学习"></a>• <a href="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE.pdf">黑马瑞吉外卖学习</a></h3>]]></content>
    
    
    <categories>
      
      <category>pdf整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发</title>
    <link href="/post/918971b1.html"/>
    <url>/post/918971b1.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-线程状态"><a href="#1-线程状态" class="headerlink" title="1. 线程状态"></a>1. 线程状态</h2><p><strong>六种状态及转换</strong></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210172239451.png" alt="image-20210831090722658"></p><p>分别是</p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><blockquote><p><em><strong>其它情况（只需了解）</strong></em></p><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul></blockquote><p><strong>五种状态</strong></p><p>五种状态的说法来自于操作系统层面的划分</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210172239752.png" alt="image-20210831092652602"></p><ul><li>运行态：分到 cpu 时间，能真正执行线程内代码的</li><li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li><li>阻塞态：没资格分到 cpu 时间的<ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等</li></ul></li><li>新建与终结态：与 java 中同名状态类似，不再啰嗦</li></ul><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><p><strong>七大参数</strong></p><ol><li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li><li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol></li></ol><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210172239687.png" alt="image-20210831093204388"></p><h2 id="3-wait-vs-sleep"><a href="#3-wait-vs-sleep" class="headerlink" title="3. wait vs sleep"></a>3. wait vs sleep</h2><p><strong>一个共同点，三个不同点</strong></p><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li><u>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</u></li><li><u>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁</u>（我放弃 cpu，但你们还可以用）</li><li><u>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁</u>（我放弃 cpu，你们也用不了）</li></ul></li></ul><h2 id="4-lock-vs-synchronized"><a href="#4-lock-vs-synchronized" class="headerlink" title="4. lock vs synchronized"></a>4. lock vs synchronized</h2><p><strong>三个层面</strong></p><p>不同点</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li><strong>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</strong></li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的<strong>互斥、同步、锁重入</strong>功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><p><strong>公平锁</strong></p><ul><li>公平锁的公平体现<ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li></ul></li><li>公平锁会降低吞吐量，一般不用</li></ul><p><strong>条件变量</strong></p><ul><li><p>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</p></li><li><p>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</p></li></ul><h2 id="5-volatile"><a href="#5-volatile" class="headerlink" title="5. volatile"></a>5. volatile</h2><p><strong>原子性</strong></p><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul><p><strong>可见性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul><p><strong>有序性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意：<ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul></li></ul><h2 id="6-悲观锁-vs-乐观锁"><a href="#6-悲观锁-vs-乐观锁" class="headerlink" title="6. 悲观锁 vs 乐观锁"></a>6. 悲观锁 vs 乐观锁</h2><p><strong>对比悲观锁与乐观锁</strong></p><ul><li><p>悲观锁的代表是 synchronized 和 Lock 锁</p><ul><li>其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】</li><li>线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li><li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li></ul></li><li><p>乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性</p><ul><li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】</li><li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li><li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数</li></ul></li></ul><h2 id="7-Hashtable-vs-ConcurrentHashMap"><a href="#7-Hashtable-vs-ConcurrentHashMap" class="headerlink" title="7. Hashtable vs ConcurrentHashMap"></a>7. Hashtable vs ConcurrentHashMap</h2><p><strong>Hashtable 对比 ConcurrentHashMap</strong></p><ul><li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li><li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li><li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li></ul><p><strong>ConcurrentHashMap 1.7</strong></p><ul><li>数据结构：<code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li><li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了</li><li>索引计算<ul><li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li><li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li></ul></li><li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍</li><li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li></ul><p><strong>ConcurrentHashMap 1.8</strong></p><ul><li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li><li>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容</li><li>扩容条件：Node 数组满 3/4 时就会扩容</li><li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode</li><li>扩容时并发 get<ul><li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li><li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</li><li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li></ul></li><li>扩容时并发 put<ul><li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li><li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li><li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li></ul></li><li>与 1.7 相比是懒惰初始化</li><li>capacity 代表预估的元素个数，capacity / factory 来计算出初始数组大小，需要贴近 $2^n$ </li><li>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3/4</li><li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li></ul><h2 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8. ThreadLocal"></a>8. ThreadLocal</h2><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li>初始容量 16，扩容因子 2/3，扩容容量翻倍</li><li>key 索引冲突后用开放寻址法解决冲突</li></ul><p><strong>弱引用 key</strong></p><p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p><ul><li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li></ul><p><strong>内存释放时机</strong></p><ul><li>被动 GC 释放 key<ul><li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li></ul></li><li>懒惰被动释放 value<ul><li>get key 时，发现是 null key，则释放其 value 内存</li><li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li></ul></li><li>主动 remove 释放 key，value<ul><li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li><li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot原理篇(1)-自动配置工作流程</title>
    <link href="/post/28c06881.html"/>
    <url>/post/28c06881.html</url>
    
    <content type="html"><![CDATA[<h2 id="YL-1-自动配置工作流程"><a href="#YL-1-自动配置工作流程" class="headerlink" title="YL-1.自动配置工作流程"></a>YL-1.自动配置工作流程</h2><p>​        自动配置是springboot技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对spring容器如何进行bean管理的过程非常熟悉才行，所以这里需要先复习一下有关spring技术中bean加载相关的知识。方式方法很多，逐一快速复习一下，查漏补缺。不过这里需要声明一点，这里列出的bean的加载方式仅仅应用于后面课程的学习，并不是所有的spring加载bean的方式。跟着我的步伐一种一种的复习，他们这些方案之间有千丝万缕的关系，顺着看完，你就懂自动配置是怎么回事了。</p><h3 id="YL-1-1-bean的加载方式"><a href="#YL-1-1-bean的加载方式" class="headerlink" title="YL-1-1.bean的加载方式"></a>YL-1-1.bean的加载方式</h3><p>​        关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。如果前面这句话看起来有障碍，可以去复习一下spring的相关知识。B站中有我尊敬的满一航老师录制的spring高级课程，链接地址如下，欢迎大家捧场，记得一键三连哦。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD"><span class="hljs-function">https://<span class="hljs-title">www.bilibili.com</span>/<span class="hljs-title">video</span>/<span class="hljs-title">BV1P44y1N7QG</span></span><br></code></pre></td></tr></table></figure><h4 id="方式一：配置文件-lt-bean-gt-标签"><a href="#方式一：配置文件-lt-bean-gt-标签" class="headerlink" title="方式一：配置文件+&lt;bean/&gt;标签"></a>方式一：配置文件+<code>&lt;bean/&gt;</code>标签</h4><p>​        最高端的食材往往只需要最简单的烹饪方法，搞错了，再来。最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部嘛就是反射机制加载成class，然后，就没有然后了，拿到了class你就可以搞定一切了。如果这句话听不太懂，请这些小盆友转战java基础高级部分复习一下反射相关知识。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--xml方式声明自己开发的bean--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Cat&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Dog&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--xml方式声明第三方开发的bean--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="方式二：配置文件扫描-注解定义bean"><a href="#方式二：配置文件扫描-注解定义bean" class="headerlink" title="方式二：配置文件扫描+注解定义bean"></a>方式二：配置文件扫描+注解定义bean</h4><p>​        由于方式一种需要将spring管控的bean全部写在xml文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解，还可以顺带起一个bean的名字（id）。这里可以使用的注解有@Component以及三个衍生注解@Service、@Controller、@Repository。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component(&quot;tom&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        当然，由于我们无法在第三方提供的技术源代码中去添加上述4个注解，因此当你需要加载第三方开发的bean的时候可以使用下列方式定义注解式的bean。@Bean定义在一个方法上方，当前方法的返回值就可以交给spring管控，记得这个方法所在的类一定要定义在@Component修饰的类中，有人会说不是@Configuration吗？建议把spring注解开发相关课程学习一下，就不会有这个疑问了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DbConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        上面提供的仅仅是bean的声明，spring并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让spring感知到这些积极的小伙伴，必须设置spring去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列xml配置设置spring去检查哪些包，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">    &quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--指定扫描加载bean的位置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.itheima.bean,com.itheima.config&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​        方式二声明bean的方式是目前企业中较为常见的bean的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean。</p><h4 id="方式三：注解方式声明配置类"><a href="#方式三：注解方式声明配置类" class="headerlink" title="方式三：注解方式声明配置类"></a>方式三：注解方式声明配置类</h4><p>​        方式二已经完美的简化了bean的声明，以后再也不用写茫茫多的配置信息了。仔细观察xml配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，使用java类替换掉这种固定格式的配置，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。嗯……，怎么说呢？方式二和方式三其实差别还是挺大的，番外篇找个时间再聊吧。</p><p>​        定义一个类并使用@ComponentScan替代原始xml配置中的包扫描这个动作，其实功能基本相同。为什么说基本，还是有差别的。先卖个关子吧，番外篇再聊。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&#123;&quot;com.itheima.bean&quot;,&quot;com.itheima.config&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig3</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DogFactoryBean <span class="hljs-title function_">dog</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DogFactoryBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用FactroyBean接口"><a href="#使用FactroyBean接口" class="headerlink" title="使用FactroyBean接口"></a>使用FactroyBean接口</h5><p>​        补充一个小知识，spring提供了一个接口FactoryBean，也可以用于声明bean，只不过实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象。如下列，造出来的bean并不是DogFactoryBean，而是Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DogFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;Dog&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Dog <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-comment">//.........</span><br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> Dog.class;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        有人说，注释中的代码写入Dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入Dog，或许初始化动作A当前并不能满足你的需要，这个时候你就要做一个DogB的方案了。然后，就没有然后了，你就要做两个Dog类。当时使用FactoryBean接口就可以完美解决这个问题。</p><p>​        通常实现了FactoryBean接口的类使用@Bean的形式进行加载，当然你也可以使用@Component去声明DogFactoryBean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&#123;&quot;com.itheima.bean&quot;,&quot;com.itheima.config&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig3</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DogFactoryBean <span class="hljs-title function_">dog</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DogFactoryBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注解格式导入XML格式配置的bean"><a href="#注解格式导入XML格式配置的bean" class="headerlink" title="注解格式导入XML格式配置的bean"></a>注解格式导入XML格式配置的bean</h5><p>​        再补充一个小知识，由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ImportResource(&quot;applicationContext1.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig32</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="proxyBeanMethods属性"><a href="#proxyBeanMethods属性" class="headerlink" title="proxyBeanMethods属性"></a>proxyBeanMethods属性</h5><p>​        前面的例子中用到了@Configuration这个注解，当我们使用AnnotationConfigApplicationContext加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的bean的唯一性。为@Configuration注解设置proxyBeanMethods属性值为true即可，由于此属性默认值为true，所以很少看见明确书写的，除非想放弃此功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Configuration(proxyBeanMethods = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig33</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">cat</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。此特性在很多底层源码中有应用，前面讲MQ时，也应用了此特性，只不过当前没有解释而已。这里算是填个坑吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App33</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig33.class);<br>        String[] names = ctx.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-------------------------&quot;</span>);<br>        <span class="hljs-type">SpringConfig33</span> <span class="hljs-variable">springConfig33</span> <span class="hljs-operator">=</span> ctx.getBean(<span class="hljs-string">&quot;springConfig33&quot;</span>, SpringConfig33.class);<br>        System.out.println(springConfig33.cat());<br>        System.out.println(springConfig33.cat());<br>        System.out.println(springConfig33.cat());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式四：使用-Import注解注入bean"><a href="#方式四：使用-Import注解注入bean" class="headerlink" title="方式四：使用@Import注解注入bean"></a>方式四：使用@Import注解注入bean</h4><p>​        使用扫描的方式加载bean是企业级开发中常见的bean的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。</p><p>​        有人就会奇怪，会有什么问题呢？比如你扫描了com.itheima.service包，后来因为业务需要，又扫描了com.itheima.dao包，你发现com.itheima包下面只有service和dao这两个包，这就简单了，直接扫描com.itheima就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有com.itheima包，这下就热闹了，该来的不该来的全来了。</p><p>​        所以我们需要一种精准制导的加载方式，使用@Import注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合@ComponentScan可以解决很多问题，但是@Import注解拥有其重要的应用场景。有没有想过假如你要加载的bean没有使用@Component修饰呢？这下就无解了，而@Import就无需考虑这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Dog.class,DbConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig4</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用-Import注解注入配置类"><a href="#使用-Import注解注入配置类" class="headerlink" title="使用@Import注解注入配置类"></a>使用@Import注解注入配置类</h5><p>​        除了加载bean，还可以使用@Import注解加载配置类。其实本质上是一样的，不解释太多了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(DogFactoryBean.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig4</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式五：编程形式注册bean"><a href="#方式五：编程形式注册bean" class="headerlink" title="方式五：编程形式注册bean"></a>方式五：编程形式注册bean</h4><p>​        前面介绍的加载bean的方式都是在容器启动阶段完成bean的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>        <span class="hljs-comment">//上下文容器对象已经初始化完毕后，手工加载bean</span><br>        ctx.register(Mouse.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>        <span class="hljs-comment">//上下文容器对象已经初始化完毕后，手工加载bean</span><br>        ctx.registerBean(<span class="hljs-string">&quot;tom&quot;</span>, Cat.class,<span class="hljs-number">0</span>);<br>        ctx.registerBean(<span class="hljs-string">&quot;tom&quot;</span>, Cat.class,<span class="hljs-number">1</span>);<br>        ctx.registerBean(<span class="hljs-string">&quot;tom&quot;</span>, Cat.class,<span class="hljs-number">2</span>);<br>        System.out.println(ctx.getBean(Cat.class));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式六：导入实现了ImportSelector接口的类"><a href="#方式六：导入实现了ImportSelector接口的类" class="headerlink" title="方式六：导入实现了ImportSelector接口的类"></a>方式六：导入实现了ImportSelector接口的类</h4><p>​        在方式五种，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。</p><p>​        现在又多了一种控制bean加载的方式，或者说是选择bean的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;<br>        <span class="hljs-comment">//各种条件的判定，判定完毕后，决定是否装载指定的bean</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> metadata.hasAnnotation(<span class="hljs-string">&quot;org.springframework.context.annotation.Configuration&quot;</span>);<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.itheima.bean.Dog&quot;</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.itheima.bean.Cat&quot;</span>&#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="方式七：导入实现了ImportBeanDefinitionRegistrar接口的类"><a href="#方式七：导入实现了ImportBeanDefinitionRegistrar接口的类" class="headerlink" title="方式七：导入实现了ImportBeanDefinitionRegistrar接口的类"></a>方式七：导入实现了ImportBeanDefinitionRegistrar接口的类</h4><p>​        方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心。BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在BeanDefinition中定义了scope属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对bean的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现ImportBeanDefinitionRegistrar接口的方式定义bean，并且还可以让你对bean的初始化进行更加细粒度的控制，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <br>            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;bookService&quot;</span>,beanDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类"><a href="#方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类" class="headerlink" title="方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类"></a>方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类</h4><p>​        上述七种方式都是在容器初始化过程中进行bean的加载或者声明，但是这里有一个bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个bean，得嘞，这下就热闹了。</p><p>​        spring挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition意思是bean定义，Registry注册的意思，Post后置，Processor处理器，全称bean定义后处理器，干啥的？在所有bean注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是最后一个运行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <br>            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;bookService&quot;</span>,beanDefinition);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​        总体上来说，上面介绍了各种各样的bean的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring源码中大量运用各种方式。复习的内容就先说到这里。</p><p><strong>总结</strong></p><ol><li>bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean</li><li>@Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载</li><li>spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean</li></ol><h3 id="YL-1-2-bean的加载控制"><a href="#YL-1-2-bean的加载控制" class="headerlink" title="YL-1-2.bean的加载控制"></a>YL-1-2.bean的加载控制</h3><p>​        前面复习bean的加载时，提出了有关加载控制的方式，其中手工注册bean，ImportSelector接口，ImportBeanDefinitionRegistrar接口，BeanDefinitionRegistryPostProcessor接口都可以控制bean的加载，这一节就来说说这些加载控制。</p><p>​        企业级开发中不可能在spring容器中进行bean的饱和式加载的。什么是饱和式加载，就是不管用不用，全部加载。比如jdk中有两万个类，那就加载两万个bean，显然是不合理的，因为你压根就不会使用其中大部分的bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些bean通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的bean。用什么技术意味着什么？就是加载对应技术的类。所以在spring容器中，通过判定是否加载了某个类来控制某些bean的加载是一种常见操作。下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.itheima.bean.Mouse&quot;</span>);<br>            <span class="hljs-keyword">if</span>(clazz != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.itheima.bean.Cat&quot;</span>&#125;;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br><span class="hljs-comment">//            e.printStackTrace();</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是springboot将把这些常用操作给我们做了一次封装。这种逻辑判定你开发者就别搞了，我springboot信不过你这种新手开发者，我给你封装一下，做几个注解，你填参数吧，耶，happy。</p><p>​        下例使用@ConditionalOnClass注解实现了当虚拟机中加载了com.itheima.bean.Wolf类时加载对应的bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnClass(name = &quot;com.itheima.bean.Wolf&quot;)</span><br><span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">tom</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​        @ConditionalOnMissingClass注解控制虚拟机中没有加载指定的类才加载对应的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingClass(&quot;com.itheima.bean.Dog&quot;)</span><br><span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">tom</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​        这种条件还可以做并且的逻辑关系，写2个就是2个条件都成立，写多个就是多个条件都成立。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnClass(name = &quot;com.itheima.bean.Wolf&quot;)</span><br><span class="hljs-meta">@ConditionalOnMissingClass(&quot;com.itheima.bean.Mouse&quot;)</span><br><span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">tom</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​        除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是web环境。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span><br><span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">tom</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​        下面是判定容器环境是否是非web环境。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnNotWebApplication</span><br><span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">tom</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​        当然还可以判定是否加载了指定名称的bean，这种有什么用呢？太有用了。比如当前容器中已经提供了jdbcTemplate对应的bean，你还需要再加载一个全新的jdbcTemplate的bean吗？没有必要了嘛。spring说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，自适应，明白？没有的话就提供给你，有的话就用你自己的，是不是很帅？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(name=&quot;jerry&quot;)</span><br><span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">tom</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​        以下就是判定当前是否加载了mysql的驱动类，如果加载了，我就给你搞一个Druid的数据源对象出来，完美！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnClass(name=&quot;com.mysql.jdbc.Driver&quot;)</span><br>    <span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        其中springboot的bean加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。</p><p><strong>总结</strong></p><ol><li>springboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean</li></ol><h3 id="YL-1-3-bean的依赖属性配置管理"><a href="#YL-1-3-bean的依赖属性配置管理" class="headerlink" title="YL-1-3.bean的依赖属性配置管理"></a>YL-1-3.bean的依赖属性配置管理</h3><p>​        bean的加载及加载控制已经搞完了，下面研究一下bean内部的事情。bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的bean的属性配置相关的知识进行灵活的配置了。先通过yml配置文件，设置bean运行需要使用的配置信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cartoon:</span><br>  <span class="hljs-attr">cat:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;图多盖洛&quot;</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">mouse:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;泰菲&quot;</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>​        然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;cartoon&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartoonProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-keyword">private</span> Mouse mouse;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        最后在使用的位置注入对应的配置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@EnableConfigurationProperties(CartoonProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartoonCatAndMouse</span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CartoonProperties cartoonProperties;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        建议在业务类上使用@EnableConfigurationProperties声明bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类CartoonProperties，减少spring管控的资源数量。</p><p><strong>总结</strong></p><ol><li>bean的运行如果需要外部设置值，建议将设置值封装成专用的属性类* * * * Properties</li><li>设置属性类加载指定前缀的配置信息</li><li>在需要使用属性类的位置通过注解@EnableConfigurationProperties加载bean，而不要直接在属性配置类上定义bean，减少资源加载的数量，因需加载而不要饱和式加载。</li></ol><h3 id="YL-1-4-自动配置原理（工作流程）"><a href="#YL-1-4-自动配置原理（工作流程）" class="headerlink" title="YL-1-4.自动配置原理（工作流程）"></a>YL-1-4.自动配置原理（工作流程）</h3><p>​        经过前面的知识复习，下面终于进入到了本章核心内容的学习，自动配置原理。原理谈不上，就是自动配置的工作流程。</p><p>​        啥叫自动配置呢？简单说就是springboot根据我们开发者的行为猜测你要做什么事情，然后把你要用的bean都给你准备好。听上去是不是很神奇？其实非常简单，前面复习的东西都已经讲完了。springboot咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的bean（注意是有可能）都给你加载好，你直接使用就行了，springboot把所需要的一切工作都做完了。</p><p>​        自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的bean根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用mysql技术，导入了mysql的坐标，springboot就知道了你要做数据库操作，一系列的数据库操作相关的bean都给你提前声明好，但是你要告诉springboot你到底用哪一个数据库，像什么IP地址啊，端口啊，你不告诉spirngboot，springboot就无法帮你把自动配置相关的工作做完。</p><p>​        而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为2个阶段：</p><p>​        <strong>阶段一：准备阶段</strong></p><ol><li><p>springboot的开发人员先大量收集Spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个<strong>技术集A</strong></p></li><li><p>收集常用技术(<strong>技术集A</strong>)的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的<strong>设置集B</strong></p><p><strong>阶段二：加载阶段</strong></p></li><li><p>springboot初始化Spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的其他坐标，形成<strong>初始化环境</strong></p></li><li><p>springboot将<strong>技术集A</strong>包含的所有技术在SpringBoot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的</p></li><li><p>springboot会对<strong>技术集A</strong>中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和其他坐标，也就是与<strong>初始化环境</strong>，这个时候就可以根据这个<strong>初始化环境</strong>与springboot的<strong>技术集A</strong>进行比对了，哪个匹配上加载哪个</p></li><li><p>因为有些技术不做配置就无法工作，所以springboot开始对<strong>设置集B</strong>下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量</p></li><li><p>但是默认配置不一定能解决问题，于是springboot开放修改<strong>设置集B</strong>的接口，可以由开发者根据需要决定是否覆盖默认配置</p></li></ol><p>​        以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想自己实现自动配置的功能，都要做哪些工作呢？</p><ul><li>首先指定一个技术X，我们打算让技术X具备自动配置的功能，这个技术X可以是任意功能，这个技术隶属于上面描述的<strong>技术集A</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartoonCatAndMouse</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>然后找出技术X使用过程中的常用配置Y，这个配置隶属于上面表述的<strong>设置集B</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cartoon:</span><br>  <span class="hljs-attr">cat:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;图多盖洛&quot;</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">mouse:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;泰菲&quot;</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>将常用配置Y设计出对应的yml配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的bean的依赖属性管理，一模一样</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;cartoon&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartoonProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-keyword">private</span> Mouse mouse;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@EnableConfigurationProperties(CartoonProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartoonCatAndMouse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br>    <span class="hljs-keyword">private</span> CartoonProperties cartoonProperties;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当然，你也可以为当前自动配置类设置上激活条件，例如使用@CondtionOn* * * * 为其设置加载条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@ConditionalOnClass(name=&quot;org.springframework.data.redis.core.RedisOperations&quot;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(CartoonProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartoonCatAndMouse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br>    <span class="hljs-keyword">private</span> CartoonProperties cartoonProperties;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        做到这里都已经做完了，但是遇到了一个全新的问题，如何让springboot启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot为我们开放了一个配置入口，在配置目录中创建META-INF目录，并创建spring.factories文件，在其中添加设置，说明哪些类要启动自动配置就可以了。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CMD"># Auto Configure<br>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>com.itheima.bean.CartoonCatAndMouse<br></code></pre></td></tr></table></figure><p>​        其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的bean的加载，和最初使用xml格式加载bean几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：</p><ol><li>自动配置从根本上来说就是一个bean的加载</li><li>通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱</li><li>使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱</li><li>springboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把spring.factories文件写好了，这是蒙蔽我们双眼的第三层面纱</li></ol><p>​        你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在springboot程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测100余种技术是否在你程序中使用。</p><p>​        以上内容是自动配置的工作流程。</p><p><strong>总结</strong></p><ol><li>springboot启动时先加载spring.factories文件中的org.springframework.boot.autoconfigure.EnableAutoConfiguration配置项，将其中配置的所有的类都加载成bean</li><li>在加载bean的时候，bean对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载bean</li><li>对于可以正常加载成bean的类，通常会通过@EnableConfigurationProperties注解初始化对应的配置属性类并加载对应的配置</li><li>配置属性类上通常会通过@ConfigurationProperties加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了</li></ol><h3 id="YL-1-5-变更自动配置"><a href="#YL-1-5-变更自动配置" class="headerlink" title="YL-1-5.变更自动配置"></a>YL-1-5.变更自动配置</h3><p>​        知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载100多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：</p><p><strong>方式一：通过yaml配置设置排除指定的自动配置类</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">autoconfigure:</span><br>    <span class="hljs-attr">exclude:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration</span><br></code></pre></td></tr></table></figure><p><strong>方式二：通过注解参数排除自动配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@EnableAutoConfiguration(excludeName = &quot;&quot;,exclude = &#123;&#125;)</span><br></code></pre></td></tr></table></figure><p><strong>方式三：排除坐标（应用面较窄）</strong></p><p>如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，你把tomcat排除掉，记得再加一种可以运行的服务器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--添加Jetty起步依赖，匹配自动配置条件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>springboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能</li></ol>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面试知识点收集</title>
    <link href="/post/906095e6.html"/>
    <url>/post/906095e6.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-ConcurrentModificationException"><a href="#1-ConcurrentModificationException" class="headerlink" title="1.ConcurrentModificationException"></a>1.ConcurrentModificationException</h2><p>ConcurrentModificationException(并发修改异常)：迭代器遍历过程中，通过集合对象修改了集合中的元素长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</p><p>ConcurrentModificationException是基于java<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>中的 <strong>快速失败（fail-fast）</strong> 机制产生的，在使用<a href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020">迭代器</a>遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了增删改，就会抛出该异常。<br>快速失败机制使得java的集合类不能在<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>下并发修改，也不能在迭代过程中被修改。</p><h4 id="1-1抛异常实例"><a href="#1-1抛异常实例" class="headerlink" title="1.1抛异常实例"></a>1.1抛异常实例</h4><p>使用迭代器遍历list，同时使用list.remove方法删除元素，会抛ConcurrentModificationException异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryRemove</span><span class="hljs-params">(List&lt;String&gt; strings)</span> &#123;<br>    Iterator&lt;String&gt; it = strings.iterator();<br>    <span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> it.next();<br>        <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;remove&quot;</span>)) &#123;<br>            strings.remove(str);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2抛异常的原因"><a href="#1-2抛异常的原因" class="headerlink" title="1.2抛异常的原因"></a>1.2抛异常的原因</h4><p>抛异常是在next方法中，该方法共有两处抛异常，上面的实例中，是在next方法的第一处抛的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>    <span class="hljs-keyword">if</span> (i &gt;= limit)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>    <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    cursor = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个modCount的作用是什么呢？<br>modCount是在AbstractList抽象类中定义，且声明为<code>protected transient</code>，该变量实际就是个修改次数的计数标志，以ArrayList为例，会在ArrayList的以下方法中执行<code>modCount++</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span> &#123; ... &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123; ... &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123; ... &#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>add方法内部会调用到ensureExplicitCapacity方法，也间接调用了modCount++。<br>这些方法的共同点：<em>变更了list的数组长度或移动了list内部的元素。只要list集合内部数组结构上发生了变更，modCount就会自增1</em>。<br>所以上面的例子中，expectedModCount值记录的是调用iterator方法时的modCount值，而调用过一次list.remove之后，modCount自增1，也就与expectedModCount不相等了，所以就抛出异常，表明在迭代过程中list被修改了而快速失败。<br>因此在使用迭代器遍历删除集合元素时，应使用迭代器的remove方法，其内部会更新expectedModCount及cursor，以避免调用next方法时抛异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    ......<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>            cursor = lastRet;<span class="hljs-comment">//更新cursor，避免next方法中的第二处抛异常</span><br>            lastRet = -<span class="hljs-number">1</span>;<br>            expectedModCount = modCount;<span class="hljs-comment">//调用remove后更新expectedModCount</span><br>            limit--;<span class="hljs-comment">//更新列表长度</span><br>        &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        &#125;<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3如何避免此异常"><a href="#1-3如何避免此异常" class="headerlink" title="1.3如何避免此异常"></a>1.3如何避免此异常</h4><p>modCount只在集合的内部迭代器中使用，所以规避该异常只需在使用迭代器时考虑迭代器内部的expectedModCount与list的modCount值是否相等，游标cursor是否可能大于数组长度。<br>基于此思考归纳出以下几点可能抛该异常的情景：</p><ul><li>迭代器遍历过程中，调用了集合的remove或add等改变了集合结构的方法；</li><li>foreach循环遍历集合，实际上隐式调用了迭代器遍历，同样调用集合的remove或add等方法会抛异常；</li><li>多线程环境下，迭代器遍历+iterator.remove也可能导致异常，因此多线程环境下建议使用并发集合或做好线程间的同步。</li></ul><p>使用<strong>ListIterator</strong>（list集合特有迭代器）不会发生并发修改异常</p><h2 id="2-Deque的认识"><a href="#2-Deque的认识" class="headerlink" title="2.Deque的认识"></a>2.Deque的认识</h2><p> deque容器为一个给定<em>*类型*<em>的元素进行</em>*线性处理*<em>，像向量一样，它</em>*能够快速地随机访问任一个元素*<em>，并且能够高效地</em>*插入和删除*<em>容器的尾部元素。但它又与<a href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020">vector</a>不同，</em>*deque支持高效插入和删除容器的头部元素*<em>，因此也叫做</em>*<strong>双端队列</strong>*</em></p><p>一个完善，可靠性高的LIFO栈操作由Deque接口</p><h2 id="3-hashCode的作用"><a href="#3-hashCode的作用" class="headerlink" title="3.hashCode的作用"></a>3.hashCode的作用</h2><p>以下是关于HashCode的官方文档定义：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。 <br>hashCode 的常规协定是： <br>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 <span class="hljs-keyword">equals</span> 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 <br>如果根据 <span class="hljs-keyword">equals</span>(<span class="hljs-type">Object</span>) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。 <br>以下情况不 是必需的：如果根据 <span class="hljs-keyword">equals</span>(java.lang.<span class="hljs-type">Object</span>) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。 <br>实际上，由 <span class="hljs-type">Object</span> 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） <br>当<span class="hljs-keyword">equals</span>方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。<br></code></pre></td></tr></table></figure><p>1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</p><p>2、如果两个对象相同，就是适用于<a href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a>(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</p><p>3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</p><p>4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们<strong>“存放在同一个篮子里”</strong>。</p><h2 id="4-为什么重写equals方法，还必须要重写hashcode方法"><a href="#4-为什么重写equals方法，还必须要重写hashcode方法" class="headerlink" title="4.为什么重写equals方法，还必须要重写hashcode方法"></a>4.为什么重写equals方法，还必须要重写hashcode方法</h2><p>为了提高效率，采取<a href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%86%99&spm=1001.2101.3001.7020">重写</a>hashcode方法，先进行hashcode比较，如果不同，那么就没必要在进行equals的比较了，这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的，一个很好的例子就是在集合中的使用；</p><p>我们都知道java中的List<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>是有序的，因此是可以重复的，而set集合是无序的，因此是不能重复的，那么怎么能保证不能被放入重复的元素呢，但靠equals方法一样比较的话，如果原来集合中以后又10000个元素了，那么放入10001个元素，难道要将前面的所有元素都进行比较，看看是否有重复，这个效率可想而知，因此hashcode就应遇而生了，java就采用了hash表，利用哈希算法（也叫散列算法），就是将对象数据根据该对象的特征使用特定的算法将其定义到一个地址上，那么在后面定义进来的数据只要看对应的hashcode地址上是否有值，那么就用equals比较，如果没有则直接插入，只要就大大减少了equals的使用次数，执行效率就大大提高了。</p><p>同时也是为了保证同一个对象，保证在<a href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a>相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。</p><p>总结来说就是两点</p><p><strong>1.使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率</strong></p><p><strong>2.保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</strong></p><p><strong>小总结：</strong></p><ul><li>hashCode主要用于提升查询效率，来确定在散列结构中对象的存储地址；</li><li>重写equals()必须重写hashCode()，二者参与计算的自身属性字段应该相同；</li><li>hash类型的存储结构，添加元素重复性校验的标准就是先取hashCode值，后判断equals()；</li><li>equals()相等的两个对象，hashcode()一定相等；</li><li>反过来：hashcode()不等，一定能推出equals()也不等；</li><li>hashcode()相等，equals()可能相等，也可能不等。</li></ul><h2 id="5-ArrayList扩容机制"><a href="#5-ArrayList扩容机制" class="headerlink" title="5.ArrayList扩容机制"></a>5.ArrayList扩容机制</h2><p>一.<a href="https://so.csdn.net/so/search?q=ArrayList&spm=1001.2101.3001.7020">ArrayList</a>继承了AbstractList，实现了List接口，底层实现基于数组，因此可以认为是一个可变长度的数组。<br>二.在讲扩容机制之前，我们需要了解一下ArrayList中最主要的几个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个空数组以供使用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">//也是一个空数组，跟上边的空数组不同之处在于，这个是在默认构造器时返回的，扩容时需要用到这个作判断，后面会讲到</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">//存放数组中的元素，注意此变量是transient修饰的，不参与序列化</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-comment">//数组的长度，此参数是数组中实际的参数，区别于elementData.length，后边会说到</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><p>三.ArrayList有三个构造函数，不同的构造函数会影响后边的扩容机制判断<br>1.默认的无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，调用此构造函数，返回了一个空的数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，此数组长度为0.<br>2.给定初始容量的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑很简单，就是构造一个具有指定长度的空数组，当initialCapacity为0时，返回EMPTY_ELEMENTDATA<br>3.包含特定集合元素的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把传入的集合转换为数组，然后通过Arrays.copyOf方法把集合中的元素拷贝到elementData中。同样，若传入的集合长度为0，返回EMPTY_ELEMENTDATA<br>四.扩容机制<br>扩容开始于集合添加元素方法，添加元素有两种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    rangeCheckForAdd(index);<br><br>   ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到两个方法都调用了ensureCapacityInternal(size + 1)方法，把数组长度加1以确保能存下下一个数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法会先调用calculateCapacity方法，此时minCapacity为1，即size+1，因为初始时size为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点来了，此方法会判断当前数组是否为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，之前就强调了无参构造时才会返回这个数组。所以，若创建ArrayList时调用的是无参构造，此方法会返回DEFAULT_CAPACITY（值为10）和minCapacity的最大值，因此，最终会返回固定值10；若创建ArrayList时调用了有参构造，则此方法会返回1，注意这个<br>minCapacity变量只是第一次调用add方法时值为1，此后的调用需要根据实际的数组长度size+1。<br>然后调用ensureExplicitCapacity方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>modCount++用到了快速失败机制，此处先不做讨论。<br>如果minCapacity大于elementData.length,则会调用grow方法，注意，这个elementData.length返回的是当前数组的容量，而不是数组实际的长度size。如果调用了有参构造，例如传入的容量为5，则此时elementData.length值即为5，而此时第一次调用add时，size值为0，因此minCapacity为1，不满足条件，此情况不需要扩容调用grow方法；如果调用了无参构造返回数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，注意这个数组只是一个空数组，因此此时elementData.length为0，满足条件，需要扩容调用grow方法。<br>可能说的太啰嗦，通俗来讲，就是如果ArrayList给定了特定初始容量，则此处需要根据实际情况确定是否调用grow方法，即有可能不需要扩容。如果没有指定初始容量，第一次调用add则此处一定需要调用grow方法。<br>那么，下面就看grow方法都做了哪些处理吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)此行代码即为扩容的核心，oldCapacity为原来的容量，右移一位，即除以2，因此这句的意思就是新的容量newCapacity=oldCapacity+oldCapacity /2，即原来的1.5倍。<br>然后判断newCapacity如果小于传入的minCapacity，则直接让newCapacity等于minCapacity，即不需要扩容计算（当无参构造时，elementData.length为0，所以oldCapacity也为0，minCapacity为10，因此最终newCapacity为10）。<br>然后判断newCapacity是否大于设定的MAX_ARRAY_SIZE，此处<br><a href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a> static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;<br>如果大于，则调用hugeCapacity方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>        MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果minCapacity大于MAX_ARRAY_SIZE，则返回Integer的最大值，否则返回MAX_ARRAY_SIZE<br>最后，通过Arrays.copyOf方法把原数组的内容放到更大容量的数组里面。</p><h2 id="6-Comparable和Comparator区别"><a href="#6-Comparable和Comparator区别" class="headerlink" title="6.Comparable和Comparator区别"></a>6.Comparable和Comparator区别</h2><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//必须实现的方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br>    <span class="hljs-comment">//选择实现</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p><em>为什么可以不实现 equals(Object obj) 函数呢？ 因为任何类，默认都是已经实现了equals(Object obj)的。 Java中的一切类都是继承于java.lang.Object，在Object.java中实现了equals(Object obj)函数；所以，其它所有的类也相当于都实现了该函数。</em></p><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>两者都是用来用作对象之间的比较，都可以自定义比较规则；</li><li>两者都是返回一个描述对象之间关系的int；</li></ol><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li>comparable 在java.lang包下，comparator在java.util包下；</li><li>实现comparable 必须重写compareTo(T o)，实现comparator必须重写compare(T o1,T o2);</li><li><strong>comparable是内在比较器</strong>，表示这个类的对象直接可以相互比较this.compareTo(this)，该类支持排序，这个类对象组成的集合就可以直接使用Collections.sort方法排序，此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。<strong>comparator是外在比较器</strong>，如果想比较两个类又没有实现comparable或者想实现比较排序的，可以用Comparator.compara(o1,o2);</li><li>comparator 是典型的策略模式（策略模式指定义一组算法类，将每个算法实现封装起来，让他们可以相互替换，不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。）每个类都可以实现comparator，都可以实现比较排序；</li><li>Comparator与Comparable同时存在的情况下，<strong>比较器Comparator优先级高。</strong></li><li>使用Comparable需要修改原先的实体类，是属于一种自然排序，而Comparator 是不用修改原先的类的实现一个新的比较器 。Comparator实际应用广</li></ol><h2 id="7-单例模式"><a href="#7-单例模式" class="headerlink" title="7.单例模式"></a>7.单例模式</h2><h3 id="7-1-什么是单例模式"><a href="#7-1-什么是单例模式" class="headerlink" title="7.1. 什么是单例模式"></a>7.1. 什么是单例模式</h3><p><strong>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。</strong>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTE1MTI2Njk4LTg5NmU2NDQzLTBmOWUtNGM4Yy1iNGEwLWJiMDRjOWUxY2I2ZC5wbmc?x-oss-process=image/format,png" alt="image.png"></p><h3 id="7-2-单例模式的类型"><a href="#7-2-单例模式的类型" class="headerlink" title="7.2. 单例模式的类型"></a>7.2. 单例模式的类型</h3><p>单例模式有两种类型：</p><ul><li>懒汉式：在<strong>真正需要使用</strong>对象时才去创建该单例类对象</li><li>饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，等待被程序使用</li></ul><h4 id="7-2-1-懒汉式创建单例对象"><a href="#7-2-1-懒汉式创建单例对象" class="headerlink" title="7.2.1 懒汉式创建单例对象"></a>7.2.1 懒汉式创建单例对象</h4><p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化<strong>（判空），</strong>若已实例化直接返回该类对象。，否则则先执行实例化操作。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTE1NTM5MjI2LWViODdmMGUxLTE2MjAtNGFmYy1iMTQwLWEzZGZiMGIxNmRjYy5wbmc?x-oss-process=image/format,png" alt="image.png"></p><p>根据上面的流程图，就可以写出下面的这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-2-2饿汉式创建单例对象"><a href="#7-2-2饿汉式创建单例对象" class="headerlink" title="7.2.2饿汉式创建单例对象"></a>7.2.2饿汉式创建单例对象</h4><p>饿汉式在<strong>类加载</strong>时已经创建好该对象，在程序调用时<strong>直接返回</strong>该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，<strong>不需要等到被调用时再去创****建</strong>。</p><p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTE4NjM2NTgyLTYzN2RjZjZhLTgwOTEtNDBkNC05YWNjLTQ2ZmFjYTllM2NkMi5wbmc?x-oss-process=image/format,png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意上面的代码在第3行已经实例化好了一个Singleton对象在内存中，不会有多个Singleton对象实例存在，类在加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡了。</p><h3 id="7-3-懒汉式如何保证只创建一个对象"><a href="#7-3-懒汉式如何保证只创建一个对象" class="headerlink" title="7.3. 懒汉式如何保证只创建一个对象"></a>7.3. 懒汉式如何保证只创建一个对象</h3><p>我们再来回顾懒汉式的核心方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>        singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法其实是存在问题的，试想一下，如果两个线程同时判断singleton为空，那么它们都会去实例化一个Singleton对象，这就变成双例了。所以，我们要解决的是<strong>线程安全</strong>问题。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTIwNjkyNjU1LWUxY2MwNTM4LTE2NWYtNDYxNS05ODgwLWJiYmI3YTFmOTJhOC5wbmc?x-oss-process=image/format,png" alt="image.png"></p><p>最容易想到的解决方法就是在方法上加锁，或者是对类对象加锁，程序就会变成下面这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>        singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;   <br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：<strong>每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</strong></p><p>接下来要做的就是<strong>优化性能，目标是：</strong>如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</p><p><strong>所以直接在方法上加锁的方式就被废掉了，因为这种方式无论如何都需要先获取锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>       <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>            <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码已经完美地解决了<strong>并发安全+性能低效</strong>问题：</p><ul><li>第2行代码，如果singleton不为空，则直接返回对象，不需要获取锁；而如果多个线程发现singleton为空，则进入分支；</li><li>第3行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton是否为空，因为singleton有可能已经被之前的线程实例化</li><li>其它之后获取到锁的线程在执行到第4行校验代码，发现singleton已经不为空了，则不会再new一个对象，直接返回对象即可</li><li>之后所有进入该方法的线程都不会去获取锁，在第一次判断singleton对象时已经不为空了</li></ul><p>因为需要两次判空，且对类对象加锁，该懒汉式写法也被称为：<strong>Double Check（双重校验） + Lock（加锁）</strong></p><p>完整的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>       singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码已经近似完美了，但是还存在最后一个问题：指令重排</p><h3 id="7-4-使用volatile防止指令重排"><a href="#7-4-使用volatile防止指令重排" class="headerlink" title="7.4. 使用volatile防止指令重排"></a>7.4. 使用volatile防止指令重排</h3><p>创建一个对象，在JVM中会经过三步：</p><p>（1）为singleton分配内存空间</p><p>（2）初始化singleton对象</p><p>（3）将singleton指向分配好的内存空间</p><p>指令重排序是指：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p><p>在这三步中，第2、3步有可能会发生指令重排现象，创建对象的顺序变为1-3-2，会导致多个线程获取对象时，有可能线程A创建对象的过程中，执行了1、3步骤，线程B判断singleton已经不为空，获取到未初始化的singleton对象，就会报NPE异常。文字较为晦涩，可以看流程图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTIyMzkwNzk3LTRkZjBkMDA4LTM3MmMtNDkxZi04YjlhLWY4NjBmODAzNzFhYi5wbmc?x-oss-process=image/format,png" alt="image.png"></p><p>使用volatile关键字可以<strong>防止指令重排序，</strong>其原理较为复杂，这篇博客不打算展开，可以这样理解：<strong>使用volatile关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换</strong>，这样在多线程环境下就不会发生NPE异常了。</p><blockquote><p>volatile还有第二个作用：使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，<strong>线程每次操作该变量都需要先读取该变量。</strong></p></blockquote><p>最终的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-5-破坏懒汉式单例与饿汉式单例"><a href="#7-5-破坏懒汉式单例与饿汉式单例" class="headerlink" title="7.5. 破坏懒汉式单例与饿汉式单例"></a>7.5. 破坏懒汉式单例与饿汉式单例</h3><p>无论是完美的懒汉式还是饿汉式，终究敌不过<strong>反射和序列化</strong>，它们俩都可以把单例对象破坏掉（产生多个对象）。</p><h5 id="1：演示利用反射破坏单例模式"><a href="#1：演示利用反射破坏单例模式" class="headerlink" title="1：演示利用反射破坏单例模式"></a>1：演示利用<strong>反射</strong>破坏单例模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 获取类的显式构造器</span><br>    Constructor&lt;Singleton&gt; construct = Singleton.class.getDeclaredConstructor();<br>    <span class="hljs-comment">// 可访问私有构造器</span><br>    construct.setAccessible(<span class="hljs-literal">true</span>); <br>    <span class="hljs-comment">// 利用反射构造新对象</span><br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> construct.newInstance(); <br>    <span class="hljs-comment">// 通过正常方式获取单例对象</span><br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> Singleton.getInstance(); <br>    System.out.println(obj1 == obj2); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述的代码一针见血了：利用反射，强制访问类的私有构造器，去创建另一个对象</p><h5 id="2：利用序列化与反序列化破坏单例模式"><a href="#2：利用序列化与反序列化破坏单例模式" class="headerlink" title="2：利用序列化与反序列化破坏单例模式"></a>2：利用<strong>序列化与反序列化</strong>破坏单例模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 创建输出流</span><br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Singleton.file&quot;</span>));<br>    <span class="hljs-comment">// 将单例对象写到文件中</span><br>    oos.writeObject(Singleton.getInstance());<br>    <span class="hljs-comment">// 从文件中读取单例对象</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Singleton.file&quot;</span>);<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file));<br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> (Singleton) ois.readObject();<br>    <span class="hljs-comment">// 判断是否是同一个对象</span><br>    System.out.println(newInstance == Singleton.getInstance()); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>两个对象地址不相等的原因是：readObject() 方法读入对象时，<strong>它必定会返回一个新的对象实例</strong>，必然指向新的内存地址。</p><h3 id="7-6-枚举实现"><a href="#7-6-枚举实现" class="headerlink" title="7.6.枚举实现"></a>7.6.枚举实现</h3><p>在 JDK1.5 后，使用 Java 语言实现单例模式的方式又多了一种：<strong>枚举</strong></p><p>我们先来看看枚举如何实现单例模式的，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是枚举类型的单例模式！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要思考：<strong>使用枚举实现单例模式的优势在哪里？</strong></p><p><strong>优势1</strong>：代码对比饿汉式与懒汉式来说，更加地简洁; 其次，既然是实现单例模式，那这种写法<strong>必定满足单例模式</strong>的要求，而且使用枚举实现时，没有做任何额外的处理。</p><p><strong>优势2</strong>：它不需要做任何额外的操作去保证对象单一性与线程安全性</p><p>我写了一段测试代码放在下面，这一段代码可以<strong>证明程序启动时仅会创建一个 Singleton 对象</strong>，且是线程安全的。</p><blockquote><p>我们可以简单地理解枚举实现单例的过程：<strong>在程序启动时，会调用Singleton的空参构造器，实例化好一个Singleton对象赋给INSTANCE，之后再也不会实例化</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    Singleton() &#123; System.out.println(<span class="hljs-string">&quot;枚举创建对象了&quot;</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-comment">/* test(); */</span> &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;<br>        System.out.print(<span class="hljs-string">&quot;t1和t2的地址是否相同：&quot;</span> + t1 == t2);<br>    &#125;<br>&#125;       <br><span class="hljs-comment">// 枚举创建对象了</span><br><span class="hljs-comment">// t1和t2的地址是否相同：true</span><br></code></pre></td></tr></table></figure><p><strong>优势3</strong>：使用枚举可以防止调用者使用<strong>反射</strong>、<strong>序列化与反序列化</strong>机制强制生成多个单例对象，破坏单例模式。</p><p>防破坏的原理如下：</p><p><strong>（1）防反射</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk1MDg0MzI2NDM4LTgxYTkwNTdiLTIwZmItNDMyOS04NDU5LWRkYjJlY2NiMGQ0NS5wbmc?x-oss-process=image/format,png" alt="image-20200718213354831.png"></p><p>枚举类默认继承了 Enum 类，在利用反射调用 newInstance() 时，会判断该类是否是一个枚举类，如果是，则抛出异常。</p><p><strong>（2）防止反序列化创建多个枚举对象</strong></p><p>在读入Singleton对象时，每个枚举类型和枚举名字都是唯一的，所以在序列化时，仅仅只是对枚举的<strong>类型和变量名</strong>输出到文件中，在读入文件反序列化成对象时，<strong>利用 Enum 类的 valueOf(String name) 方法</strong>根据变量的名字查找对应的枚举对象。</p><p>所以，在序列化和反序列化的过程中，只是写出和读入了<strong>枚举类型和名字</strong>，没有任何关于对象的操作。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk1MDg0MzY4MDE5LWQ2NzUzNzg1LWM0ZWMtNGI4MC05ODFlLWEzNzFjOWJlNDE5Yy5wbmc?x-oss-process=image/format,png" alt="image-20200718224707754.png"></p><p>小总结：</p><p>（1）Enum 类内部使用<strong>Enum 类型判定</strong>防止通过反射创建多个对象</p><p>（2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），<strong>通过 valueOf() 方法匹配枚举名</strong>找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</p><p>（3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与<strong>饿汉式单例有异曲同工之妙</strong>。</p><h3 id="7-7-总结"><a href="#7-7-总结" class="headerlink" title="7.7.总结"></a>7.7.总结</h3><p>（1）单例模式常见的写法有两种：<strong>懒汉式、饿汉式</strong></p><p>（2）懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：<strong>Double Check + Lock</strong>，解决了并发安全和性能低下问题</p><p>（3）饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</p><p>（4）在开发中如果对<strong>内存要求非常高</strong>，那么使用懒汉式写法，可以在特定时候才创建该对象；</p><p>（5）如果对内存要求不高使用饿汉式写法，因为<strong>简单不易出错</strong>，且没有任何并发安全和性能问题</p><p>（6）为了防止多线程环境下，因为指令重排序导致变量报NPE，<strong>需要在单例对象上添加volatile关键字防止指令重排序</strong></p><p>（7）最优雅的实现方式是使用<strong>枚举</strong>，其代码精简，没有线程安全问题，且 Enum 类内部<strong>防止反射和反序列化时破坏单例</strong>。</p><h2 id="8-Spring-AOP和Spring-IOC"><a href="#8-Spring-AOP和Spring-IOC" class="headerlink" title="8.Spring AOP和Spring IOC"></a>8.Spring AOP和Spring IOC</h2><h3 id="8-1-Spring-AOP"><a href="#8-1-Spring-AOP" class="headerlink" title="8.1 Spring AOP"></a>8.1 Spring AOP</h3><p>AOP（Aspect Oriented Programming），面向切面编程，通过预编译方式和运行期动态代理实现程序功能，AOP可是说是OOP的延续，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的复用性，提高开发效率。AOP底层是通过Spring提供的动态代理技术实现的，在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，再去调用目标对象的方法，从而完成功能的增强</p><h2 id="9-浏览器输入域名后发生"><a href="#9-浏览器输入域名后发生" class="headerlink" title="9.浏览器输入域名后发生"></a>9.浏览器输入域名后发生</h2><p>1.DNS解析</p><p>2.建立TCP连接</p><p>3.发送HTTP请求</p><p>4.服务器解析请求</p><p>5.返回HTTP响应</p><p>6.TCP四次挥手</p><p>7.浏览器解析HTML</p><h2 id="10-mysql优化"><a href="#10-mysql优化" class="headerlink" title="10.mysql优化"></a>10.mysql优化</h2><h3 id="SELECT语句-执行顺序："><a href="#SELECT语句-执行顺序：" class="headerlink" title="SELECT语句 - 执行顺序："></a>SELECT语句 - 执行顺序：</h3><blockquote><p><strong>FROM</strong><br>&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。<br><strong>ON</strong><br>&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选<br><strong>JOIN</strong> &lt;join, left join, right join…&gt;<br>&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中<br><strong>WHERE</strong><br>&lt;where条件&gt; # 对上述虚表进行筛选<br><strong>GROUP BY</strong><br>&lt;分组条件&gt; # 分组<br>&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的<br><strong>HAVING</strong><br>&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选<br><strong>SELECT</strong><br>&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外<br><strong>DISTINCT</strong><br># 数据除重<br><strong>ORDER BY</strong><br>&lt;排序条件&gt; # 排序<br><strong>LIMIT</strong><br>&lt;行数限制&gt;</p></blockquote><h3 id="不使用-Select"><a href="#不使用-Select" class="headerlink" title="不使用 Select*"></a>不使用 Select*</h3><p>使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。</p><p>建议提出业务实际需要的列数，将指定列名以取代select *</p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>执行下面sql查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,age <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>可通过普通索引列(age) 就能获取SQL所需的所有列数据，无需回表，速度更快。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> 分析:<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8815cd770955423c84e78a89dda111b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR54ix5aSn6aOO5ZKM54OI6YWS,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p> 可通过Extra 是否是Using Index 判断查询是否索引覆盖</p><p>如何实现索引覆盖: 将被查询的字段，建立到联合索引里去</p><p>哪些场景适合使用索引覆盖来优化SQL</p><ul><li>全表count查询优化 </li><li>列查询回表优化</li><li>分页查询</li></ul><h3 id="在mysql中，float和double都是浮点数类型："><a href="#在mysql中，float和double都是浮点数类型：" class="headerlink" title="在mysql中，float和double都是浮点数类型："></a>在mysql中，float和double都是<a href="https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9&spm=1001.2101.3001.7020">浮点</a>数类型：</h3><ul><li>float 占4个字节，精度是6位；</li><li>double 占8个字节，精度是16位；</li></ul><h3 id="MySQL主从复制原理"><a href="#MySQL主从复制原理" class="headerlink" title="MySQL主从复制原理"></a>MySQL主从复制原理</h3><p>MySQL的主从复制和MySQL的读写分离两者有必然的联系，首先要部署主从复制，只有主从复制完成了，才能在此基础上进行数据的读写分离</p><h4 id="1）MySQL支持的复制类型"><a href="#1）MySQL支持的复制类型" class="headerlink" title="1）MySQL支持的复制类型"></a>1）MySQL支持的复制类型</h4><p>（1）基于语句的复制：在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。但是必须开启二进制日志功能；<br>（2）基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍；<br>（3）混合类型的复制：默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制；</p><h4 id="2）复制的工作过程"><a href="#2）复制的工作过程" class="headerlink" title="2）复制的工作过程"></a>2）复制的工作过程</h4><p>MySQL复制的工作过程详细介绍：<br>1.在每个事务更新数据完成之前，Master在二进制日志记录这些变化。写入二进制日志完成后，Master通知存储引擎提交事务；<br>2.Slave将Master的Binary log（二进制日志）复制到其Relay log（中继日志）。首先Slave开始一个工作进程——I/O线程，I/O线程在Master上打开一个普通的连接，然后开始Binlog dump process（二进制日志转储过程）。Binlog dump process从Master的二进制日志中读取事件，如果已经跟上Master，它就会睡眠并等待Master产生新的事件。I/O线程将这些时间写入中继日志；<br>3.SQL slave thread（SQL从线程）处理该过程的最后一步。SQL线程从中继日志中读取事件，并重放其中的事件而更新Slave的数据，使其与Master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小；</p><p>复制过程有一个很重要的限制，即复制在Slave上是串行化的，也就是说Master上的并行更新操作不能在Slave上并行操作。<br><img src="https://img-blog.csdnimg.cn/1815452b819c404196c6736779e79ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2FuZG3kuLZEZW1vbg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><a href="https://so.csdn.net/so/search?q=%E7%8A%B6%E6%80%81%E7%A0%81&spm=1001.2101.3001.7020">状态码</a></h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>当用户在浏览网页的时候，浏览器会返回一个http状态码，主要是用来响应浏览器的请求。通常情况下，一般是3位数字，http状态码是由RFC 2616来定义的，所有的状态码的第一个数字就代表着是什么状态。</p><h3 id="2、状态码的分类"><a href="#2、状态码的分类" class="headerlink" title="2、状态码的分类"></a>2、状态码的分类</h3><p>1xx<br>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</p><p>2xx<br>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p><p>3xx<br>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 location 域中指明。</p><p>4xx<br>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p><p>5xx<br>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p><h3 id="3、http常用状态码有哪些"><a href="#3、http常用状态码有哪些" class="headerlink" title="3、http常用状态码有哪些"></a>3、http常用状态码有哪些</h3><p><strong>200</strong><br>HTTP 200 状态码表示请求成功，并且所发送的请求希望返回响应，如果在访问网站或者查看网站空间日志的时候，看到200则表示正常。</p><p><strong>301</strong><br>HTTP 301 状态码可能对于运维人员并不是很陌生，一般网站在进行跳转的时候，会用到301，一般情况下，由于域名到期，或者域名不去续费，进行将资源进行转移到其他的网站上，301是一种永久的重定向。</p><p><strong>302</strong><br>HTTP 302 状态码是HTTP协议中的一个状态码(Status Code)。可以简单的理解为该资源原本确实存在，但已经被临时改变了位置；换而言之，就是请求的资源暂时驻留在不同的URI下，故而除非特别指定了缓存头部指示，该状态码不可缓存。</p><p><strong>304</strong><br>如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。简单的表达就是：服务端已经执行了GET，但文件未变化。</p><p><strong>307</strong><br>307为临时重定向，如果重定向307的原请求不是get或者head方法，那么浏览器一定会自动的进行重定向，即便location有url，也应该忽略。</p><p>状态码 307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化。当响应状态码为 302 的时候，一些旧有的用户代理会错误地将请求方法转换为 GET：使用非 GET 请求方法而返回 302 状态码，Web 应用的运行状况是不可预测的；而返回 307 状态码时则是可预测的。对于 GET 请求来说，两种情况没有区别。</p><p><strong>308</strong><br>在HTTP协议中，308 Permanent Redirect(永久重定向)是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由Location首部指定的URL上。浏览器会进行重定向，同时搜索引擎也会更新其链接(用SEO的行话来说，意思是“链接汁”(linkjuice)被传递到了新的 URL)</p><p><strong>400</strong><br>HTTP 400 状态码告诉客户端它发送了一条异常请求。400页面是当用户在打开网页时，返回给用户界面带有400提示符的页面。其含义是你访问的页面域名不存在或者请求错误。主要分为两种。</p><p><strong>401</strong><br>请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。</p><p><strong>403</strong><br>服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。</p><p><strong>404</strong> 状态码<br>当用户在访问网站的时候，可能会出现404页面，出现404页面的原因可能就是请求的资源不存在，页面可能被删除。</p><p><strong>500</strong><br>HTTP 500 状态码也是最常见的一种状态码，相信很多程序员都遇到过，500表示是网站的服务器出现问题，但是不同的状态码代表服务器出现的问题不一样。</p><p><strong>501</strong><br>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</p><p><strong>503</strong><br>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算课程实验</title>
    <link href="/post/5c6b54bf.html"/>
    <url>/post/5c6b54bf.html</url>
    
    <content type="html"><![CDATA[<h1 id="配置ssh免密登录"><a href="#配置ssh免密登录" class="headerlink" title="配置ssh免密登录"></a>配置ssh免密登录</h1><p>vim /etc/hosts</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">47.103.211.80</span>node1<br><span class="hljs-number">110.40.220.94</span>node2<br><span class="hljs-number">43.139.46.197</span>node3<br></code></pre></td></tr></table></figure><p>测试三个节点是否能够ping通</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244497.png" alt="image-20221005133035326"></p><p>node1,node2,node3分别生成服务器密钥</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-keygen -t dsa -P <span class="hljs-string">&#x27;&#x27;</span> -f ~<span class="hljs-regexp">/.ssh/i</span>d_dsa<br></code></pre></td></tr></table></figure><p>分别将密钥加到authorized_keys中</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">node1:</span>cat id_dsa.pub &gt;&gt; authorized_keys<br><span class="hljs-symbol">node2:</span>cat id_dsa.pub &gt;&gt; authorized_keys1<br><span class="hljs-symbol">node3:</span>cat id_dsa.pub &gt;&gt; authorized_keys2<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244578.png" alt="image-20221006231520047"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244510.png" alt="image-20221006231539018"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244588.png" alt="image-20221006231553891"></p><p>将node2的authorized_keys1和node3的authorized_keys2分发到 node1</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">node2:</span>scp authorized_keys1 root<span class="hljs-variable">@node1</span><span class="hljs-symbol">:~/</span>.ssh/<br><span class="hljs-symbol">node3:</span>scp authorized_keys2 root<span class="hljs-variable">@node1</span><span class="hljs-symbol">:~/</span>.ssh/<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244468.png" alt="image-20221006231619407"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244006.png" alt="image-20221006231632884"></p><p>在node1中 将authorized_keys1和authorized_keys1追加到 authorized_keys中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> authorized_keys1 &gt;&gt; authorized_keys<br><span class="hljs-built_in">cat</span> authorized_keys2 &gt;&gt; authorized_keys<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244793.png" alt="image-20221006231657384"></p><p>这样node1中 就有三个节点的密钥了，将node1中的authorized_keys分发到 node2，node3</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp authorized_keys root<span class="hljs-variable">@node2</span><span class="hljs-symbol">:~/</span>.ssh/<br>scp authorized_keys root<span class="hljs-variable">@node3</span><span class="hljs-symbol">:~/</span>.ssh/<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244688.png" alt="image-20221006231720808"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244709.png" alt="image-20221006231836697"></p><p>测试：</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244400.png" alt="image-20221006231752451"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244734.png" alt="image-20221006231804027"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244517.png" alt="image-20221006231815424"></p><h1 id="Hadoop集群搭建"><a href="#Hadoop集群搭建" class="headerlink" title="Hadoop集群搭建"></a>Hadoop集群搭建</h1><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>将Hadoop压缩包上传到Centos7中指定目录 <strong>（三台主机进行同样的操作）</strong></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244638.png" alt="image-20221006234103045"></p><p>目录结果如下</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244553.png" alt="image-20221006234125916"></p><p>配置Java环境变量</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vim</span> hadoop-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">5</span>/etc/hadoop/hadoop-env.sh<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244497.png" alt="image-20221006234239764"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">vim core-site.<span class="hljs-keyword">xml</span> <span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244754.png" alt="image-20221006234644816"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://node1:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/opt/hadoop/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim hdfs-site.xml<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191429626.png" alt="image-20221019142944382"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br> <span class="hljs-comment">&lt;!-- 设置namenode的http通讯地址 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node1:50090<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.http-address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node1:9870<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 设置hdfs副本数量 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- 设置namenode存放的路径 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/opt/hadoop/hdfs/name<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- 设置datanode存放的路径 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:/opt/hadoop/hdfs/data<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意这里的路径（设置datanode存放的路径）要根据自己的Hadoop存放路径修改</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim mapred-site.xml<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191432163.png" alt="image-20221019143220068"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 通知框架MR使用YARN --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node1:10020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node1:19888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> yarn-site.xml<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191433071.png" alt="image-20221019143319118"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Site specific YARN configuration properties --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- reducer取数据的方式是mapreduce_shuffle --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>启动HDFS</p><p>进入Hadoop的bin目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./hdfs namenode -format<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191440719.png" alt="image-20221019144028819"></p><p>格式化：hdfs namenode -format</p><p>格式化后会在配置的目录(/opt/hadoop)下生成fsimage 文件</p><p>在node1中Hadoop的sbin目录下，统一启动HDFS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./start-dfs.sh<br></code></pre></td></tr></table></figure><p>启动Hadoop集群</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span>-<span class="hljs-keyword">all</span>.sh<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191443538.png" alt="image-20221019144358247"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191444115.png" alt="image-20221019144419125"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191444301.png" alt="image-20221019144430506"></p><p><strong>使用jps命令，node1节点出现namenode，node2，node3出现DataNode即为成功</strong> </p><p>浏览器访问网址<a href="http://47.103.211.88:9870，IP和端口根据自己的而定">http://47.103.211.88:9870，IP和端口根据自己的而定</a></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191448093.png" alt="image-20221019144836004"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191449083.png" alt="image-20221019144859233"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>启动NameNode时报错</p><figure class="highlight profile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs profile"><span class="hljs-number">2022</span><span class="hljs-number">-10</span><span class="hljs-number">-19</span> <span class="hljs-number">14</span>:<span class="hljs-number">19</span>:<span class="hljs-number">21</span>,<span class="hljs-number">198</span> INFO org.apache.hadoop.http.HttpServer2: addJerseyResourcePackage: packageName=org.apache.hadoop.hdfs.server.namenode.web.resources;org.apache.hadoop.hdfs.web.resources, pathSpec=/webhdfs/v1/*<br>2022-10-19 14:<span class="hljs-number">19</span>:<span class="hljs-number">21</span>,<span class="hljs-number">217</span> INFO org.apache.hadoop.http.HttpServer2: HttpServer.start() threw a non Bind IOException<br>java.net.BindException: Port in use: node1:<span class="hljs-number">9870</span><br>at org.apache.hadoop.http.HttpServer2.openListeners(HttpServer2.java:<span class="hljs-number">892</span>)<br>at org.apache.hadoop.http.HttpServer2.start(HttpServer2.java:<span class="hljs-number">828</span>)<br>at org.apache.hadoop.hdfs.server.namenode.NameNodeHttpServer.start(NameNodeHttpServer.java:<span class="hljs-number">142</span>)<br>at org.apache.hadoop.hdfs.server.namenode.NameNode.startHttpServer(NameNode.java:<span class="hljs-number">706</span>)<br>at org.apache.hadoop.hdfs.server.namenode.NameNode.initialize(NameNode.java:<span class="hljs-number">593</span>)<br>at org.apache.hadoop.hdfs.server.namenode.NameNode.&lt;init&gt;(NameNode.java:<span class="hljs-number">765</span>)<br>at org.apache.hadoop.hdfs.server.namenode.NameNode.&lt;init&gt;(NameNode.java:<span class="hljs-number">749</span>)<br>at org.apache.hadoop.hdfs.server.namenode.NameNode.createNameNode(NameNode.java:<span class="hljs-number">1446</span>)<br>at org.apache.hadoop.hdfs.server.namenode.NameNode.main(NameNode.java:<span class="hljs-number">1512</span>)<br>Caused by: java.net.BindException: Cannot assign requested address<br>at sun.nio.ch.Net.bind0(Native Method)<br>at sun.nio.ch.Net.bind(Net.java:<span class="hljs-number">433</span>)<br>at sun.nio.ch.Net.bind(Net.java:<span class="hljs-number">425</span>)<br>at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:<span class="hljs-number">223</span>)<br>at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:<span class="hljs-number">74</span>)<br>at org.mortbay.jetty.nio.SelectChannelConnector.open(SelectChannelConnector.java:<span class="hljs-number">216</span>)<br>at org.apache.hadoop.http.HttpServer2.openListeners(HttpServer2.java:<span class="hljs-number">887</span>)<br>... <span class="hljs-number">8</span> more<br></code></pre></td></tr></table></figure><p>解决方式：将公网NameNode的公网IP改成内网IP</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191454256.png" alt="image-20221019145407113"></p><blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><a href="https://blog.csdn.net/zhangvalue/article/details/80883788?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166615978116782412521794%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166615978116782412521794&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-80883788-null-null.142%5Ev59%5Epc_search_tree,201%5Ev3%5Econtrol_1&utm_term=Hadoop%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99java.net.BindException:%20Cannot%20assign%20requested%20address&spm=1018.2226.3001.4187">参考链接</a></h2></blockquote><h1 id="zookeeper集群搭建"><a href="#zookeeper集群搭建" class="headerlink" title="zookeeper集群搭建"></a>zookeeper集群搭建</h1><h1 id="Hbase集群搭建"><a href="#Hbase集群搭建" class="headerlink" title="Hbase集群搭建"></a>Hbase集群搭建</h1><p>上传hbase压缩包到指定目录并解压，目录结构如下</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191500912.png" alt="image-20221019150041477"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191501427.png" alt="image-20221019150116354"></p><p>配置环境变量</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191502937.png" alt="image-20221019150236593"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#hbase   </span><br>export HBASE_HOME=<span class="hljs-regexp">/opt/</span>hbase<span class="hljs-regexp">/hbase-1.1.3  /</span>**根据自己目录配置*/<br>export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HBase_HOME</span>/bin<br></code></pre></td></tr></table></figure><p>配置conf目录下的hbase-env.sh文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> base-env.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p>找到JAVA_HOME，去掉注释，修改为实际的JAVA_HOME路径</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191506158.png" alt="image-20221019150628190"></p><p>设置不使用内置zookeeper，在非编辑状态下输入/HBASE_MANA进行搜索，将</p><p># export HBASE_MANAGES_ZK=true中去掉注释，并将true改为false：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">HBASE_MANAGES_ZK</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191507084.png" alt="image-20221019150717175"></p><p>编辑hbase-site.xml文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> hbase-site.xml<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191510409.png" alt="image-20221019151039237"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 指定hbase在HDFS上存储的路径 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.rootdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://node1:9000/hbase<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> #hadoop配置文件core-site.xml中配置<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.cluster.distributed<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>#zookeeper节点配置<br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>node1,node2,node3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.node1.maxclockskew<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2700000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> #先设置小一点，如果报错再调大点<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/opt/hbase/data/temp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看下core-site.xml中内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/opt/</span>hadoop<span class="hljs-regexp">/hadoop-2.6.5/</span>etc<span class="hljs-regexp">/hadoop/</span>core-site.xml<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191513650.png" alt="image-20221019151314522"></p><p><strong>新建一个HDFS****的文件夹</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -<span class="hljs-built_in">mkdir</span> /hbase<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191515032.png" alt="image-20221019151503759"></p><p>将hadoop中hdfs-site.xml拷贝到HBASE_HOME/conf下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">scp <span class="hljs-regexp">/opt/</span>hadoop<span class="hljs-regexp">/hadoop-2.6.5/</span>etc<span class="hljs-regexp">/hadoop/</span>hdfs-site.xml <span class="hljs-regexp">/opt/</span>hbase<span class="hljs-regexp">/hbase-1.1.3/</span>conf/<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191522950.png" alt="image-20221019152233977"></p><p>配置conf目录下的regionservers</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">vi regionservers</span><br></code></pre></td></tr></table></figure><p>将local host改为node2，node3</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191525203.png" alt="image-20221019152542226"></p><p>为保证集群的可靠性，要启动多个HNode1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./hbase-daemon.sh start node1<br></code></pre></td></tr></table></figure><p>前提：hadoop集群已启动，如果没启动，请依次启动。<br>启动所有的hbase</p><p> <strong>需要在安装了zk****的每台节点上启动</strong>zk</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">zkServer.sh <span class="hljs-literal">start</span> <br></code></pre></td></tr></table></figure><p> 进入bin目录 启动hbase集群，启动hbase，在node1主节点上运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./start-dfs.sh<br><br>./start-yarn.sh<br></code></pre></td></tr></table></figure><p>使用jps查看是否正常启动</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191717660.png" alt="image-20221019171738424"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191717118.png" alt="image-20221019171758091"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210191718886.png" alt="image-20221019171826534"></p><h1 id="Flume的安装与部署"><a href="#Flume的安装与部署" class="headerlink" title="Flume的安装与部署"></a>Flume的安装与部署</h1><h1 id="Storm集群搭建"><a href="#Storm集群搭建" class="headerlink" title="Storm集群搭建"></a>Storm集群搭建</h1>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔试总结</title>
    <link href="/post/429e5162.html"/>
    <url>/post/429e5162.html</url>
    
    <content type="html"><![CDATA[<h1 id="浙江保融"><a href="#浙江保融" class="headerlink" title="浙江保融"></a>浙江保融</h1><p>间接寻址</p><p>数据库语句-分组</p><p><strong>设计模式：使用设计模式取代if-else</strong></p><p><strong>跑步模拟：十个人主备就绪，号令响，十个人同时起跑</strong></p><h1 id="上海威弘"><a href="#上海威弘" class="headerlink" title="上海威弘"></a>上海威弘</h1><p>字符流</p><p>构造方法</p><p>Array List扩容</p><p>集合类继承</p><p>Thread类中方法</p><p>rabbitMQ的作用</p><p>MySQL优化建议</p><p>redis持久化和优化 </p><p>Mysql语句</p><h1 id="武汉源启"><a href="#武汉源启" class="headerlink" title="武汉源启"></a>武汉源启</h1><p>JDK和JRE的区别</p><p>join，left join，right join的区别</p><p>Java创建对象的方法</p><p>RPC，常见的RPC框架</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Waline评论系统的使用</title>
    <link href="/post/da27ec23.html"/>
    <url>/post/da27ec23.html</url>
    
    <content type="html"><![CDATA[<p>本文介绍基于**LeanCloud+Vercel **方式</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210111443690.png" alt="image-20221011144308113"></p><h1 id="LeanCloud-设置-数据库"><a href="#LeanCloud-设置-数据库" class="headerlink" title="LeanCloud 设置 (数据库)"></a>LeanCloud 设置 (数据库)</h1><ol><li><a href="https://console.leancloud.app/login">登录<em><strong>*open in new window*</strong></em></a> 或 <a href="https://console.leancloud.app/register">注册<em><strong>*open in new window*</strong></em></a> <code>LeanCloud 国际版</code> 并进入 <a href="https://console.leancloud.app/apps">控制台<em><strong>*open in new window*</strong></em></a></li><li>点击左上角 <a href="https://console.leancloud.app/apps">创建应用<em><strong>*open in new window*</strong></em></a> 并起一个你喜欢的名字 (请选择免费的开发版)</li></ol><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122207879.png" alt="image-20221012220733979"></p><p>3.<strong>进入应用，选择左下角的</strong> <code>设置</code> <strong>&gt;</strong> <code>应用 Key</code><strong>。你可以看到你的</strong> <code>APP ID</code><strong>,</strong><code>APP Key</code> <strong>和</strong> <code>Master Key</code><strong>。请记录它们，以便后续使用。</strong></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122209209.png" alt="image-20221012220920855"></p><p>国内版需要完成备案接入</p><p>如果你正在使用 Leancloud 国内版 (<a href="https://leancloud.cn/">leancloud.cn<em><strong>*open in new window*</strong></em></a>)，我们推荐你切换到国际版 (<a href="https://leancloud.app/">leancloud.app<em><strong>*open in new window*</strong></em></a>)。否则，你需要为应用额外绑定<strong>已备案</strong>的域名，同时购买独立 IP 并完成备案接入:</p><ul><li>登录国内版并进入需要使用的应用</li><li>选择 <code>设置</code> &gt; <code>域名绑定</code> &gt; <code>API 访问域名</code> &gt; <code>绑定新域名</code> &gt; 输入域名 &gt; <code>确定</code>。</li><li>按照页面上的提示按要求在 自己的域名服务商DNS 上完成 CNAME 解析。</li></ul><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122212658.png" alt="image-20221012221200267"></p><h1 id="Vercel-部署-服务端"><a href="#Vercel-部署-服务端" class="headerlink" title="Vercel 部署 (服务端)"></a>Vercel 部署 (服务端)</h1><p><a href="https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example"><img src="https://vercel.com/button" alt="Vercel"><em><strong>*open in new window*</strong></em></a></p><ol><li><p>点击上方按钮，跳转至 Vercel 进行 Server 端部署。</p><p>注</p><p>如果你未登录的话，Vercel 会让你注册或登录，请使用 GitHub 账户进行快捷登录。</p></li><li><p>输入一个你喜欢的 Vercel 项目名称并点击 <code>Create</code> 继续:</p><p><img src="https://waline.js.org/assets/vercel-1.4e9dd7aa.png" alt="创建项目"></p></li><li><p>此时 Vercel 会基于 Waline 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。</p><p><img src="https://waline.js.org/assets/vercel-3.0918fcee.png" alt="deploy"></p><p>一两分钟后，满屏的烟花会庆祝你部署成功。此时点击 <code>Go to Dashboard</code> 可以跳转到应用的控制台。</p><p><img src="https://waline.js.org/assets/vercel-4.f7f4c12b.png" alt="deploy"></p></li><li><p>点击顶部的 <code>Settings</code> - <code>Environment Variables</code> 进入环境变量配置页，并配置三个环境变量 <code>LEAN_ID</code>, <code>LEAN_KEY</code> 和 <code>LEAN_MASTER_KEY</code> 。它们的值分别对应上一步在 LeanCloud 中获得的 <code>APP ID</code>, <code>APP KEY</code>, <code>Master Key</code>。</p><p><img src="https://waline.js.org/assets/vercel-5.3a5de7f0.png" alt="设置环境变量"></p><p>注</p><p>如果你使用 LeanCloud 国内版，请额外配置 <code>LEAN_SERVER</code> 环境变量，值为你绑定好的域名。</p></li><li><p>环境变量配置完成之后点击顶部的 <code>Deployments</code> 点击顶部最新的一次部署右侧的 <code>Redeploy</code> 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。</p><p><img src="https://waline.js.org/assets/vercel-6.c1af01b1.png" alt="redeploy"></p></li><li><p>此时会跳转到 <code>Overview</code> 界面开始部署，等待片刻后 <code>STATUS</code> 会变成 <code>Ready</code>。此时请点击 <code>Visit</code> ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122213684.png" alt="image-20221012221331250"></p></li></ol><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122214387.png" alt="image-20221012221411161"></p><h1 id="绑定域名-可选"><a href="#绑定域名-可选" class="headerlink" title="绑定域名 (可选)"></a>绑定域名 (可选)</h1><ol><li><p>点击顶部的 <code>Settings</code> - <code>Domains</code> 进入域名配置页</p></li><li><p>输入需要绑定的域名并点击 <code>Add</code></p><p><img src="https://waline.js.org/assets/vercel-8.49378bd3.png" alt="Add domain"></p></li><li><p>在域名服务器商处添加新的 <code>CNAME</code> 解析记录</p><table><thead><tr><th>Type</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>CNAME</td><td>example</td><td>cname.vercel-dns.com</td></tr></tbody></table></li><li><p>等待生效，你可以通过自己的域名来访问了🎉</p><ul><li>评论系统：example.yourdomain.com</li><li>评论管理：example.yourdomain.com/ui</li></ul><p><img src="https://waline.js.org/assets/vercel-9.a29236ac.png" alt="success"></p></li></ol><h1 id="hexo-fluid主题引入Waline"><a href="#hexo-fluid主题引入Waline" class="headerlink" title="hexo-fluid主题引入Waline"></a>hexo-fluid主题引入Waline</h1><p>主题配置文件_config.yml中修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugin</span><br><span class="hljs-attr">comments:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">waline</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Waline</span><br><span class="hljs-comment"># 从 Valine 衍生而来，额外增加了服务端和多种功能</span><br><span class="hljs-comment"># Derived from Valine, with self-hosted service and new features</span><br><span class="hljs-comment"># See: https://waline.js.org/</span><br><span class="hljs-attr">waline:</span><br>  <span class="hljs-attr">serverURL:</span> <span class="hljs-string">&#x27;自己的评论地址，即上面部署成功后可跳转的那个链接&#x27;</span> <br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">highlighter:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">requiredMeta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>]<br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  <span class="hljs-attr">emoji:</span> [<span class="hljs-string">&#x27;https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo&#x27;</span>]<br>  <span class="hljs-attr">dark:</span> <span class="hljs-string">&#x27;html[data-user-color-scheme=&quot;dark&quot;]&#x27;</span><br>  <span class="hljs-attr">wordLimit:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">6</span><br>  <span class="hljs-attr">pageview:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>修改fluid\themes\fluid\layout_partials\comments\waline.ejs文件</p><p><strong>在顶部添加</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 你需要自行修改替换 `v2` 为你想要的版本号 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@waline/client@v2.13.0/dist/waline.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改server URL</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122221742.png" alt="image-20221012222154433"></p><p>完整的fluid\themes\fluid\layout_partials\comments\waline.ejs文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 你需要自行修改替换 <span class="hljs-string">`v2`</span> 为你想要的版本号 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@waline/client@v2.13.0/dist/waline.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>&lt;% <span class="hljs-keyword">if</span> (theme.<span class="hljs-property">waline</span>.<span class="hljs-property">serverURL</span>) &#123; %&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;waline&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">loadComments</span>(<span class="hljs-string">&#x27;#waline&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">createCssLink</span>(<span class="hljs-string">&#x27;&lt;%= url_join(theme.static_prefix.waline, &#x27;</span>waline.<span class="hljs-property">min</span>.<span class="hljs-property">css</span><span class="hljs-string">&#x27;) %&gt;&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">createScript</span>(<span class="hljs-string">&#x27;&lt;%= url_join(theme.static_prefix.waline, &#x27;</span>waline.<span class="hljs-property">min</span>.<span class="hljs-property">js</span><span class="hljs-string">&#x27;) %&gt;&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> options = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(</span></span><br><span class="language-javascript"><span class="language-xml">          &lt;%- <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(theme.<span class="hljs-property">waline</span> || &#123;&#125;) %&gt;,</span></span><br><span class="language-javascript"><span class="language-xml">          &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#waline&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">path</span>: &lt;%= theme.<span class="hljs-property">waline</span>.<span class="hljs-property">path</span> %&gt;,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">reaction</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启反应</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">comment</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 统计评论数</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">serverURL</span>: <span class="hljs-string">&#x27;自己url&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">          &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        )</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">Waline</span>.<span class="hljs-title function_">init</span>(options);</span></span><br><span class="language-javascript"><span class="language-xml">        </span></span><br><span class="language-javascript"><span class="language-xml">        wa_ccc = <span class="hljs-string">&quot;waline-comment-count-container&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> i=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(wa_ccc)</span></span><br><span class="language-javascript"><span class="language-xml">        i.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;inline&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">waitElementVisible</span>(<span class="hljs-string">&#x27;#waline .vcontent&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">var</span> imgSelector = <span class="hljs-string">&#x27;#waline .vcontent img:not(.vemoji)&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">imageCaption</span>(imgSelector);</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">fancyBox</span>(imgSelector);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>Please enable JavaScript to view the comments<span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span></span><br>&lt;% &#125; %&gt;<br><br><br></code></pre></td></tr></table></figure><p>重新部署</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><p>成功样式</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122223116.png" alt="image-20221012222347658"></p><h1 id="配置邮箱提示"><a href="#配置邮箱提示" class="headerlink" title="配置邮箱提示"></a>配置邮箱提示</h1><p>当网站有用户发布评论或者用户回复评论时，Waline 支持对博主和回复评论作者进行通知。</p><ul><li>博主通知支持多种方式，包括 QQ、微信、邮件等。</li><li>当访客的评论收到回复时，我们会对访客进行邮件通知。</li></ul><h2 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a><a href="https://waline.js.org/guide/server/notification.html">邮件通知</a></h2><p>邮件通知需要配置以下环境变量:</p><ul><li><p><code>SMTP_SERVICE</code>: SMTP 邮件发送服务提供商,例如：QQ。</p><p>提示</p><p>你可以在 <a href="https://github.com/nodemailer/nodemailer/blob/master/lib/well-known/services.json">这里<em><strong>*open in new window*</strong></em></a> 查看所有支持的运营商。</p><p>如果你的运营商不受支持，你必须填写 <code>SMTP_HOST</code> 和 <code>SMTP_PORT</code>。</p><ul><li><code>SMTP_HOST</code>: SMTP 服务器地址，一般可以在邮箱的设置中找到。</li><li><code>SMTP_PORT</code>: SMTP 服务器端口，一般可以在邮箱的设置中找到。</li></ul></li><li><p><code>SMTP_USER</code>: SMTP 邮件发送服务的用户名，一般为登录邮箱。</p></li><li><p><code>SMTP_PASS</code>: SMTP 邮件发送服务的密码，一般为邮箱登录密码，部分邮箱(例如 163)是单独的 SMTP 密码。</p></li><li><p><code>SMTP_SECURE</code>: 是否使用 SSL 连接 SMTP。</p></li><li><p><code>SITE_NAME</code>: 网站名称，用于在消息中显示。</p></li><li><p><code>SITE_URL</code>: 网站地址，用于在消息中显示。</p></li><li><p><code>AUTHOR_EMAIL</code>: 博主邮箱，用来接收新评论通知。如果是博主发布的评论则不进行提醒通知。</p></li></ul><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122230877.png" alt="image-20221012223007629"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://waline.js.org/guide/get-started.html">Waline官方教程</a></p></li><li><p><a href="https://blog.csdn.net/qq_39788788/article/details/125708517?ops_request_misc=&request_id=&biz_id=102&utm_term=Waline%E8%AF%84%E8%AE%BA%E6%8C%82%E4%BB%B6&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-125708517.142%5Ev53%5Econtrol,201%5Ev3%5Econtrol_1&spm=1018.2226.3001.4187">Next主题增加Waline评论系统</a></p></li><li><p><a href="https://www.zywvvd.com/">https://www.zywvvd.com/</a></p></li><li><p><a href="http://minghuijia.cn/2022/03/14/Hexo-fluid%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E7%BB%9F%E8%AE%A1%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E9%87%8F/"><strong>Hexo-fluid主题设置统计博客阅读量与评论</strong></a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pdf查看</title>
    <link href="/post/48a0f817.html"/>
    <url>/post/48a0f817.html</url>
    
    <content type="html"><![CDATA[<h1 id="此种方法只支持pc显示"><a href="#此种方法只支持pc显示" class="headerlink" title="此种方法只支持pc显示"></a>此种方法只支持pc显示</h1><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&#123;% pdf &#x27;https://pdf<span class="hljs-number">-1310995062</span>.cos.ap-nanjing.myqcloud.com/SpringBoot<span class="hljs-variable">%E5</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%AC</span><span class="hljs-variable">%94</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%B0.pdf</span>&#x27; %&#125;<br><br></code></pre></td></tr></table></figure><div class="row">    <embed src="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="此方法不能加载pdf"><a href="#此方法不能加载pdf" class="headerlink" title="此方法不能加载pdf"></a>此方法不能加载pdf</h1><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&lt;iframe src<span class="hljs-operator">=</span>&#x27;/js/pdfjs/web/viewer.html?file<span class="hljs-operator">=</span>https://pdf<span class="hljs-number">-1310995062</span>.cos.ap-nanjing.myqcloud.com/SpringBoot<span class="hljs-variable">%E5</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%AC</span><span class="hljs-variable">%94</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%B0.pdf</span>&#x27; <br>style<span class="hljs-operator">=</span>&#x27;width:<span class="hljs-number">100</span>%<span class="hljs-comment">;height:100%&#x27;&gt;&lt;/iframe&gt;</span><br></code></pre></td></tr></table></figure><iframe src='/js/pdfjs/web/viewer.html?file=https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf' style='width:100%;height:100%'></iframe><h1 id="此方法显示区域太小"><a href="#此方法显示区域太小" class="headerlink" title="此方法显示区域太小"></a>此方法显示区域太小</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&lt;embed src=<span class="hljs-string">&quot;https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf&quot;</span> type=<span class="hljs-string">&quot;application/pdf&quot;</span> width=<span class="hljs-string">&quot;100%&quot; height=&quot;</span><span class="hljs-number">100</span>%&quot;&gt;  <br></code></pre></td></tr></table></figure><embed src="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf" type="application/pdf" width="100%" height="100%">  ]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker常用命令</title>
    <link href="/post/749ad7d8.html"/>
    <url>/post/749ad7d8.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span><br><br></code></pre></td></tr></table></figure><h1 id="1-Docker中文件挂载启动命令"><a href="#1-Docker中文件挂载启动命令" class="headerlink" title="1.Docker中文件挂载启动命令"></a>1.Docker中文件挂载启动命令</h1><h2 id="1-1挂载方式1—-数据卷挂载"><a href="#1-1挂载方式1—-数据卷挂载" class="headerlink" title="1.1挂载方式1—-数据卷挂载"></a>1.1挂载方式1—-数据卷挂载</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br>  --name nginx <span class="hljs-string">\</span><br>  -v html:/root/html <span class="hljs-string">\</span><br>  -p <span class="hljs-number">8081</span>:<span class="hljs-number">80</span><span class="hljs-string">\</span><br>  nginx <br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 查看html数据卷的位置</span><br>docker volume inspect html<br><span class="hljs-comment"># 进入该目录</span><br>cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>volumes<span class="hljs-regexp">/html/</span>_data<br><span class="hljs-comment"># 修改文件</span><br>vim index.html<br></code></pre></td></tr></table></figure><h2 id="1-2挂载方式2—-目录直接挂载"><a href="#1-2挂载方式2—-目录直接挂载" class="headerlink" title="1.2挂载方式2—-目录直接挂载"></a>1.2挂载方式2—-目录直接挂载</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run\<br>--name mysql\<br>    -e MYSQL_ROOT_PASSWORD=root\<br>    -p <span class="hljs-number">33061</span>:<span class="hljs-number">3306</span>\<br>    -v <span class="hljs-regexp">/tmp/my</span>sql<span class="hljs-regexp">/conf/</span>hmy.cnf:<span class="hljs-regexp">/etc/my</span>sql<span class="hljs-regexp">/conf.d/</span>hmy.cnf\<br>    -v <span class="hljs-regexp">/tmp/my</span>sql<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql\<br>    -d mysql<br></code></pre></td></tr></table></figure><h1 id="2-自定义Docker镜像"><a href="#2-自定义Docker镜像" class="headerlink" title="2.自定义Docker镜像"></a>2.自定义Docker镜像</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker build -<span class="hljs-keyword">tag</span> <span class="hljs-title">镜像名称:版本 .(.代表dockerfile</span>所在的目录) 名称必须是小写，不然会报以下错误<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -t javawebdemo:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> .<br></code></pre></td></tr></table></figure><p><u><strong>invalid argument “javawebDemo:1.0” for “-t, –tag” flag: invalid reference format: repository name must be lowercase</u></strong></p><p><strong><u>无效参数“javawebDemo:1.0”的“-t，——tag”标志:无效的引用格式:存储库名称必须是小写的</strong></u></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">运行：<br>docker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name web -p 8090:8090 -d javawebdemo:1.0</span><br></code></pre></td></tr></table></figure><h1 id="3-DockerCompose安装"><a href="#3-DockerCompose安装" class="headerlink" title="3.DockerCompose安装"></a>3.DockerCompose安装</h1><h2 id="3-1-下载"><a href="#3-1-下载" class="headerlink" title="3.1.下载"></a>3.1.下载</h2><p>Linux下需要通过命令下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装</span><br>curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`<span class="hljs-built_in">uname</span> -s`-`<span class="hljs-built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082209501.png" alt="image-20210417133020614"></p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h2 id="3-2-修改文件权限"><a href="#3-2-修改文件权限" class="headerlink" title="3.2.修改文件权限"></a>3.2.修改文件权限</h2><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改权限</span><br><span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h2 id="3-3-Base自动补全命令"><a href="#3-3-Base自动补全命令" class="headerlink" title="3.3.Base自动补全命令"></a>3.3.Base自动补全命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 补全命令</span><br>curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose<br></code></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h2 id="3-4-部署集群项目"><a href="#3-4-部署集群项目" class="headerlink" title="3.4.部署集群项目"></a>3.4.部署集群项目</h2><p>进入项目目录，然后运行下面的命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span><br></code></pre></td></tr></table></figure><p>撤销部署：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose down -d</span><br></code></pre></td></tr></table></figure><h1 id="4-Docker中项目部署常用命令"><a href="#4-Docker中项目部署常用命令" class="headerlink" title="4.Docker中项目部署常用命令"></a>4.Docker中项目部署常用命令</h1><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it mn bash<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul></li></ul><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="5-1-简化版镜像仓库"><a href="#5-1-简化版镜像仓库" class="headerlink" title="5.1.简化版镜像仓库"></a>5.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d \<br>    --restart=always \<br>    --name registry\<br>    -p 5000:5000 \<br>    -v registry-data:/var/lib/registry \<br>    registry<br></code></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="5-2-带有图形化界面版本"><a href="#5-2-带有图形化界面版本" class="headerlink" title="5.2.带有图形化界面版本"></a>5.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./registry-data:/var/lib/registry</span><br>  <span class="hljs-attr">ui:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">joxit/docker-registry-ui:static</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_TITLE=传智教育私有仓库</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_URL=http://registry:5000</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">registry</span><br></code></pre></td></tr></table></figure><h2 id="5-3-配置Docker信任地址"><a href="#5-3-配置Docker信任地址" class="headerlink" title="5.3.配置Docker信任地址"></a>5.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 打开要修改的文件</span><br>vi /etc/docker/daemon.json<br><span class="hljs-comment"># 添加内容：</span><br><span class="hljs-string">&quot;insecure-registries&quot;</span>:[<span class="hljs-string">&quot;http://110.40.220.94:8088&quot;</span>]<br><span class="hljs-comment"># 重加载</span><br>systemctl daemon-reload<br><span class="hljs-comment"># 重启docker</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="5-4-推送、拉取镜像"><a href="#5-4-推送、拉取镜像" class="headerlink" title="5.4.推送、拉取镜像"></a>5.4.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag nginx:latest 110.40.220.94:8088/nginx:1.0 <br></code></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 110.40.220.94:8088/nginx:1.0 <br></code></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 110.40.220.94:8088/nginx:1.0 <br></code></pre></td></tr></table></figure><h1 id="6-RabbitMQ"><a href="#6-RabbitMQ" class="headerlink" title="6.RabbitMQ"></a>6.RabbitMQ</h1><p><strong>版本需要使用management版本 的，不然没有管理界面</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_USER=root <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_PASS=root <span class="hljs-string">\</span><br> --name rabbitmq <span class="hljs-string">\</span><br> --hostname my-rabbit <span class="hljs-string">\</span><br> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> <span class="hljs-string">\</span><br> -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> <span class="hljs-string">\</span><br> -d <span class="hljs-string">\</span><br> rabbitmq:management<br></code></pre></td></tr></table></figure><h1 id="7-ElasticSearch"><a href="#7-ElasticSearch" class="headerlink" title="7.ElasticSearch"></a>7.ElasticSearch</h1><h2 id="7-1运行es"><a href="#7-1运行es" class="headerlink" title="7.1运行es"></a>7.1运行es</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d \<br>--name es \<br>    -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \<br>    -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br>    -e <span class="hljs-string">&quot;http.host=0.0.0.0&quot;</span> \<br>    -v es-data:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>data \<br>    -v es-plugins:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>plugins \<br>    -v es-logs:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>logs \<br>    --privileged \<br>    --network es-net \<br>    -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> \<br>    elasticsearch:<span class="hljs-number">8.4</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><h2 id="7-2部署kibana"><a href="#7-2部署kibana" class="headerlink" title="7.2部署kibana"></a>7.2部署kibana</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d \<br>--name kibana \<br>-e <span class="hljs-attribute">ELASTICSEARCH_HOSTS</span>=http://172.18.0.2:9200 \<br><span class="hljs-attribute">--network</span>=es-net \<br>-p 5601:5601  \<br>kibana:8.4.1<br></code></pre></td></tr></table></figure><p>控制台不能连接9200的解决办法：</p><ul><li><p>进入ES容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<br></code></pre></td></tr></table></figure></li><li><p>查看ip（docker内部局域网的ip）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/hosts<br></code></pre></td></tr></table></figure><p>我们将看到下面的内容：<br><img src="https://img-blog.csdnimg.cn/20200925134424472.png#pic_center" alt="在这里插入图片描述"></p><p>我们可以知道es容器在docker中的ip是<code>172.17.0.3</code></p></li><li><p>接下来就可以根据这个ip来创建容器啦</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it -d -e <span class="hljs-attribute">ELASTICSEARCH_URL</span>=http://172.17.0.3:9200 --name kibana -p 5601:5601 kibana<br></code></pre></td></tr></table></figure></li></ul><h2 id="7-3离线安装ik插件（推荐）"><a href="#7-3离线安装ik插件（推荐）" class="headerlink" title="7.3离线安装ik插件（推荐）"></a>7.3离线安装ik插件（推荐）</h2><h3 id="1）查看数据卷目录"><a href="#1）查看数据卷目录" class="headerlink" title="1）查看数据卷目录"></a>1）查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume inspect es-plugins<br></code></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;CreatedAt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2022-05-06T10:06:34+08:00&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Mountpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es-plugins&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code>这个目录中。</p><h3 id="2）解压缩分词器安装包"><a href="#2）解压缩分词器安装包" class="headerlink" title="2）解压缩分词器安装包"></a>2）解压缩分词器安装包</h3><p>下面我们需要把课前资料中的ik分词器解压缩，重命名为ik</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082210463.png" alt="image-20210506110249144"></p><h3 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a>3）上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data </code>：</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082210064.png" alt="image-20210506110704293"></p><h3 id="4）重启容器"><a href="#4）重启容器" class="headerlink" title="4）重启容器"></a>4）重启容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">4、重启容器</span><br>docker restart es<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看es日志</span><br>docker logs -f es<br></code></pre></td></tr></table></figure><h3 id="5）测试："><a href="#5）测试：" class="headerlink" title="5）测试："></a>5）测试：</h3><p>IK分词器包含两种模式：</p><ul><li><p><code>ik_smart</code>：最少切分</p></li><li><p><code>ik_max_word</code>：最细切分</p></li></ul><h2 id="7-4问题解决-—-gt-分词器没有挂在到plugins目录下"><a href="#7-4问题解决-—-gt-分词器没有挂在到plugins目录下" class="headerlink" title="7.4问题解决 —-&gt;分词器没有挂在到plugins目录下"></a>7.4问题解决 —-&gt;分词器没有挂在到plugins目录下</h2><p>\5. 进入<a href="https://so.csdn.net/so/search?q=docker&spm=1001.2101.3001.7020">docker</a> 安装elasticSearch 的容器 查看plugins</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<br><span class="hljs-built_in">cd</span> plugins <br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201114111732680.png#pic_center" alt="在这里插入图片描述"><br>6.查看当前的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201114111914484.png#pic_center" alt="在这里插入图片描述"><br>7.回到解压ik<a href="https://so.csdn.net/so/search?q=%E5%88%86%E8%AF%8D&spm=1001.2101.3001.7020">分词</a>器的目录，copy到容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> ik elasticsearch:/usr/share/elasticsearch/plugins<br>参数说明；elasticsearch docker容器名称<br>/usr/share/elasticsearch/plugins 容器所在的位置<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201114112021510.png#pic_center" alt="在这里插入图片描述"><br>\8. 查看plugins 是否成功</p><p><img src="https://img-blog.csdnimg.cn/20201114112239518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQ5MzEw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>9.重起elasticSearch 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart elasticseacher<br></code></pre></td></tr></table></figure><h3 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h3><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<br></code></pre></td></tr></table></figure><p>在线下载并安装</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">./bin/elasticsearch-plugin install <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/github.com/medcl</span><span class="hljs-regexp">/elasticsearch-analysis-ik/releases</span><span class="hljs-regexp">/download/v</span>8.<span class="hljs-number">4.1</span>/elasticsearch-analysis-ik-<span class="hljs-number">8.4</span>.<span class="hljs-number">1</span>.zip<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/316924125878132d289dc7ea3bf99b70.png" alt="img"></p><p>进入plugins可以看到IK分词器已经安装成功</p><p><img src="https://img-blog.csdnimg.cn/img_convert/241af36b392cf1a09e169c5e45b5b600.png" alt="img"></p><h3 id="安装拼音分词插件"><a href="#安装拼音分词插件" class="headerlink" title="安装拼音分词插件"></a>安装拼音分词插件</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>elasticsearch-plugin install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/medcl/</span>elasticsearch-analysis-pinyin<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v8.4.1/</span>elasticsearch-analysis-pinyin-<span class="hljs-number">8.4</span>.<span class="hljs-number">1</span>.zip<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器搭建</title>
    <link href="/post/cb9cca01.html"/>
    <url>/post/cb9cca01.html</url>
    
    <content type="html"><![CDATA[<h1 id="Centos配置Java8环境"><a href="#Centos配置Java8环境" class="headerlink" title="Centos配置Java8环境"></a>Centos配置Java8环境</h1><p>卸载jdk</p><p>1、先输入java -version 查看是否安装了jdk</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">java -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>2、如果安装了，检查下安装的路径 which java（查看JDK的安装路径）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> java<br></code></pre></td></tr></table></figure><p>3、卸载 rm -rf JDK地址（卸载JDK）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">rm -rf <span class="hljs-regexp">/usr/</span>java<span class="hljs-regexp">/jdk/</span>jdk1.<span class="hljs-number">8.0</span>_65/<br></code></pre></td></tr></table></figure><p>4、vim命令编辑文件profile</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>1.上传并解压</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204956.png" alt="image-20220906220816921"></p><p>2.编辑配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>profile 并添加下列语句<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/opt/java/jdk1.8.0_211<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HIOME</span>/jre/lib/rt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar<br></code></pre></td></tr></table></figure><p>重载配置文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>查看是否配置成功</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Java-<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204503.png" alt="image-20220906221246518"></p><h1 id="Centos配置MySql"><a href="#Centos配置MySql" class="headerlink" title="Centos配置MySql"></a>Centos配置MySql</h1><p>1.上传MySQL压缩包并解压重命名</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204392.png" alt="image-20220906224442525"></p><p>2.编写配置文件</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204469.png" alt="image-20220906225518458"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># vi <span class="hljs-regexp">/etc/my</span>.cnf<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 设置mysql客户端默认字符集</span><br><span class="hljs-attribute">default-character-set</span>=utf8 <br><span class="hljs-attribute">socket</span>=/var/lib/mysql/mysql.sock<br><br>[mysqld]<br>skip-name-resolve<br><span class="hljs-comment">#设置3306端口</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">port </span>= 3306 <br><span class="hljs-attribute">socket</span>=/var/lib/mysql/mysql.sock<br><span class="hljs-comment"># 设置mysql的安装目录, 这里的目录一定要是你解压后并且改了名的目录哟..</span><br><span class="hljs-attribute">basedir</span>=/usr/local/mysql-5.5.40<br><span class="hljs-comment"># 设置mysql数据库的数据的存放目录, 这里的目录一定要是你解压后并且改了名的目录哟..</span><br><span class="hljs-attribute">datadir</span>=/usr/local/mysql-5.5.40/data<br><span class="hljs-comment"># 允许最大连接数</span><br><span class="hljs-attribute">max_connections</span>=200<br><span class="hljs-comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="hljs-attribute">character-set-server</span>=utf8<br><span class="hljs-comment"># 创建新表时将使用的默认存储引擎</span><br><span class="hljs-attribute">default-storage-engine</span>=INNODB<br><span class="hljs-attribute">lower_case_table_name</span>=1<br><span class="hljs-attribute">max_allowed_packet</span>=16M<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204973.png" alt="image-20220907004719041"></p><h1 id="服务器配置HTTPS访问"><a href="#服务器配置HTTPS访问" class="headerlink" title="服务器配置HTTPS访问"></a>服务器配置HTTPS访问</h1><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204050.png" alt="image-20220907161559932"></p><p>修改 <code>server.xml</code> 文件 <code>Connector</code>的属性为以下内容：                                                                                                       </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;Connector <span class="hljs-attribute">port</span>=<span class="hljs-string">&quot;443&quot;</span>  <br><span class="hljs-attribute">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span><br>    <span class="hljs-attribute">SSLEnabled</span>=<span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attribute">scheme</span>=<span class="hljs-string">&quot;https&quot;</span><br>    <span class="hljs-attribute">secure</span>=<span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attribute">keystoreFile</span>=<span class="hljs-string">&quot;/usr/*/conf/cloud.tencent.com.pfx&quot;</span> #证书保存的路径<br>    <span class="hljs-attribute">keystoreType</span>=<span class="hljs-string">&quot;PKCS12&quot;</span><br>    <span class="hljs-attribute">keystorePass</span>=<span class="hljs-string">&quot;证书密码&quot;</span>  # 请替换为 keystorePass.txt 密码文件中的内容。<br>    <span class="hljs-attribute">clientAuth</span>=<span class="hljs-string">&quot;false&quot;</span><br>    <span class="hljs-attribute">SSLProtocol</span>=<span class="hljs-string">&quot;TLSv1.1+TLSv1.2+TLSv1.3&quot;</span>   <span class="hljs-attribute">ciphers</span>=<span class="hljs-string">&quot;TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>配置文件的主要参数说明如下：</p><ul><li><strong>keystoreFile</strong>：证书文件的存放位置，可以指定绝对路径，也可以指定相对于  <CATALINA_HOME> （Tomcat 安装目录）环境变量的相对路径。如果此项没有设定，默认情况下，Tomcat  将从当前操作系统用户的用户目录下读取名为 “.keystore” 的文件。</li><li><strong>keystorePass</strong>：密码文件密码，指定 keystore 的密码。申请证书时若设置了私钥密码，请填写私钥密码；若申请证书时未设置私钥密码，请填写<code>cloud.tencent.com_tomcat</code> 文件夹中 keystorePass.txt 文件内的密码。</li><li><strong>clientAuth</strong>：如果设为 true，表示 Tomcat 要求所有的 SSL 客户出示安全证书，对 SSL 客户进行身份验证。</li></ul><h4 id="HTTP-自动跳转-HTTPS-的安全配置（可选）"><a href="#HTTP-自动跳转-HTTPS-的安全配置（可选）" class="headerlink" title="HTTP 自动跳转 HTTPS 的安全配置（可选）"></a>HTTP 自动跳转 HTTPS 的安全配置（可选）</h4><p>如果您需要将 HTTP 请求自动重定向到 HTTPS。您可以通过以下操作设置：</p><p>编辑  <code>/usr/*/conf</code> 目录下的 <code>web.xml</code> 文件，找到 </welcome-file-list> 标签。</p><p>请在结束标签 </welcome-file-list> 后面换行，并添加以下内容                                                                                                               </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">login-config</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- Authorization setting for SSL --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">auth-method</span>&gt;</span>CLIENT-CERT<span class="hljs-tag">&lt;/<span class="hljs-name">auth-method</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">realm-name</span>&gt;</span>Client Cert Users-only Area<span class="hljs-tag">&lt;/<span class="hljs-name">realm-name</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">login-config</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">security-constraint</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- Authorization setting for SSL --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">web-resource-collection</span> &gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">web-resource-name</span> &gt;</span>SSL<span class="hljs-tag">&lt;/<span class="hljs-name">web-resource-name</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">web-resource-collection</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">user-data-constraint</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">transport-guarantee</span>&gt;</span>CONFIDENTIAL<span class="hljs-tag">&lt;/<span class="hljs-name">transport-guarantee</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">user-data-constraint</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">security-constraint</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编辑 server.xml</p><p> 文件，将 redirectPort 参数修改为 SSL 的 connector 的端口，即443端口。如下所示：                                                                                  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;Connector port<span class="hljs-operator">=</span><span class="hljs-string">&quot;80&quot;</span> protocol<span class="hljs-operator">=</span><span class="hljs-string">&quot;HTTP/1.1&quot;</span><br>  connectionTimeout<span class="hljs-operator">=</span><span class="hljs-string">&quot;20000&quot;</span><br>  redirectPort<span class="hljs-operator">=</span><span class="hljs-string">&quot;443&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><blockquote><p>说明：              </p><p>此修改操作可将非 SSL 的 connector 跳转到 SSL 的 connector 中。</p></blockquote><p> 目录下执行以下命令，关闭 Tomcat 服务器。                                                                                                               </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">./shutdown.sh<br></code></pre></td></tr></table></figure><p>执行以下命令，确认配置是否存在问题。                                                                                                                   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configtest.sh<br></code></pre></td></tr></table></figure><ul><li>若存在，请您重新配置或者根据提示修改存在问题。</li><li>若不存在，请执行下一步。</li></ul><p>执行以下命令，启动 Tomcat 服务器，即可使用 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>cloud.tencent.com<br></code></pre></td></tr></table></figure><p> 进行访问。                                                                                                               </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./startup.sh<br></code></pre></td></tr></table></figure><h1 id="Tomcat配置"><a href="#Tomcat配置" class="headerlink" title="Tomcat配置"></a>Tomcat配置</h1><p>添加环境变量</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082205926.png" alt="image-20220907161959334"></p><p>配置默认访问界面</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082205723.png" alt="image-20220907162053091"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;Context path<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span> docBase<span class="hljs-operator">=</span><span class="hljs-string">&quot;blog/&quot;</span>  reloadable<span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span> debug<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> crossContext<span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h1 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h1><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082205629.png" alt="image-20220926122700969"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#user  nobody;</span><br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">#error_log  logs/error.log;</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;</span><br><span class="hljs-comment">#error_log  logs/error.log  info;</span><br><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><br>    <span class="hljs-comment">#access_log  logs/access.log  main;</span><br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br><br>        <span class="hljs-comment">#charset koi8-r;</span><br><br>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span><br><br>        <span class="hljs-section">location</span>  / &#123;<br>            <span class="hljs-attribute">root</span>   /work/class_manager/pc/dist;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>            <span class="hljs-comment">#开启后不会导致刷新白屏</span><br>            <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>        &#125;<br><br>        <span class="hljs-comment"># 接口访问路径，解决跨域</span><br>        <span class="hljs-section">location</span> /springbootajax/ &#123;<br>                <span class="hljs-attribute">proxy_pass</span> http://39.105.13.178:8345/springbootajax;<br>        &#125;<br><br><br>        <span class="hljs-comment">#error_page  404              /404.html;</span><br><br>        <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-section">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试知识点汇总</title>
    <link href="/post/d3309499.html"/>
    <url>/post/d3309499.html</url>
    
    <content type="html"><![CDATA[<h1 id="东软集团（武汉）有限公司"><a href="#东软集团（武汉）有限公司" class="headerlink" title="东软集团（武汉）有限公司"></a>东软集团（武汉）有限公司</h1><p>介绍一下面向对象 </p><p> 介绍一下知道的IO流 </p><p> 线程的状态 什么时候导致运行状态的改变 </p><p> 为什么要用线程池 </p><p> java集合的分类 说几个常用的集合</p><p> 了解JVM什么 </p><p> 了解一个对象是怎么创建的吗，创建对象的过程 </p><p> BIO NIO区别，阻塞是指什么 </p><p> 怎么定义一个spring的bean </p><p> spring里面如何配置单例 </p><p> spring怎么设置<a href="">数据</a>库的事务 </p><p> 学习的时候喜欢深入学习还是业务完成</p><p> String ， StrinBuffer， Stringbuilder</p><p> File类中的方法</p><p> 项目介绍</p><p> SpringBoot的理解</p><p> Android框架</p><p>  线程和进程</p><h1 id="腾讯云智研发"><a href="#腾讯云智研发" class="headerlink" title="腾讯云智研发"></a>腾讯云智研发</h1><p> 三次握手，四次挥手</p><p> TCP特殊报文</p><p> Linux CPU使用率</p><p> 系统调用fork</p><p> 按照文件名查找文件</p><p> 单例模式</p><p> MySQL索引覆盖</p><p> 不适用select * 的原因</p><p> Redis</p><p> 网站输入域名后回车会发生什么</p><p> HTTP协议</p><h1 id="开科支付中心"><a href="#开科支付中心" class="headerlink" title="开科支付中心"></a>开科支付中心</h1><p>  String类中常用方法</p><p>  Array List优缺点</p><p> MySQL查询什么时候走索引（索引覆盖）</p><p> MySQL中float 和 double</p><p> Sping AOP 的使用场景</p><p> Spring常用注解</p><p> Ajax前后端交互</p><p> Linux常用命令</p><p> SpringIOC</p><p> MySQL主从复制实现原理</p><p> Redis的作用，举例</p><p> Redis缓存击穿，缓存穿透，缓存雪崩</p><p> 事务的隔离级别</p><p> 脏读，幻读，不可重复读</p><p> PutMapping，GetMapping等，及使用它们的原因</p><p> 状态介绍 300 400 500</p><h1 id="湖北地信科技"><a href="#湖北地信科技" class="headerlink" title="湖北地信科技"></a>湖北地信科技</h1><p>使用Java实现拦截器</p><p>AOP-面向切面编程</p><p>docker搭建</p><p>ElasticSearch使用</p><p>百度地图API开放平台</p><h1 id="南京海泰"><a href="#南京海泰" class="headerlink" title="南京海泰"></a>南京海泰</h1><p>Java基本<strong>数据</strong>类型</p><p>项目部署方式 </p><p>读写分离原理</p><p>介绍redis的使用场景</p><p>sleep和wait的区别</p><p>eclipse和idea各自的优缺点</p><p>final，finally，finalize的区别</p><p>String和String Buffer的区别</p><p>对数据表<strong>记录</strong>的增删改查</p><p>jQuery的特有表达方式</p><p>jQuery获取元素值</p><p>jsp和servlet的区别</p><h1 id="杭州奇点云"><a href="#杭州奇点云" class="headerlink" title="杭州奇点云"></a>杭州奇点云</h1><p>项目介绍</p><p>对Spring的理解</p><p>注册bean的方式</p><p>AOP的使用</p><p>直播接口设计思路</p><p>腾讯云对象存储方式，原理</p><p>MySQL读写分离哪些公司用到</p><p>高并发不使用MySQL</p><p><strong>git flow</strong> 分支管理</p><p>Nacos和Gateway的作用</p><p>Nginx和Gateway都可以做路由分发，它们的区别</p><p>项目中用到的<strong>锁</strong></p><p>在团队合作方面如何保证</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署常见命令</title>
    <link href="/post/1a17ef30.html"/>
    <url>/post/1a17ef30.html</url>
    
    <content type="html"><![CDATA[<h1 id="服务器部署常见命令"><a href="#服务器部署常见命令" class="headerlink" title="服务器部署常见命令"></a>服务器部署常见命令</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">nohup <span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>工程.<span class="hljs-keyword">jar </span>&amp;&gt;slan.log &amp;<br></code></pre></td></tr></table></figure><p>nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行，</p><p>当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。</p><p><strong>其它常用方法</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">netstat <span class="hljs-literal">-tunlp</span> | grep ××  查询出端口为××在运行应用的线程ip<br><span class="hljs-built_in">kill</span> <span class="hljs-literal">-9</span> ××   关闭线程ip 为 ××的应用<br><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> ××.jar 移除×× .jar 文件<br>java <span class="hljs-literal">-jar</span> NettyAPI.jar <span class="hljs-literal">-server</span>.port=<span class="hljs-number">9898</span><br></code></pre></td></tr></table></figure><p><strong>部署完成</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef| <span class="hljs-keyword">grep</span> java 查看是否部置成功<br></code></pre></td></tr></table></figure><p><strong>配至访问端口</strong></p><h4 id="rpm文件命令"><a href="#rpm文件命令" class="headerlink" title="rpm文件命令"></a>rpm文件命令</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>RPM 安装操作命令： <br><br>rpm -<span class="hljs-selector-tag">i</span> 需要安装的包文件名<br><br>举例如下：<br><br>rpm -<span class="hljs-selector-tag">i</span> example<span class="hljs-selector-class">.rpm</span> 安装 example<span class="hljs-selector-class">.rpm</span> 包； <br><br>rpm -iv example<span class="hljs-selector-class">.rpm</span> 安装 example<span class="hljs-selector-class">.rpm</span> 包并在安装过程中显示正在安装的文件信息； <br><br>rpm -ivh example<span class="hljs-selector-class">.rpm</span> 安装 example<span class="hljs-selector-class">.rpm</span> 包并在安装过程中显示正在安装的文件信息及安装进度； <br></code></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">.\startup.cmd -m standalone<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">031025375070,</span><span class="hljs-number">211905375145</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署项目至GitHub</title>
    <link href="/post/14fc6d5d.html"/>
    <url>/post/14fc6d5d.html</url>
    
    <content type="html"><![CDATA[<h3 id="配置-config-yml文件"><a href="#配置-config-yml文件" class="headerlink" title="配置_config.yml文件"></a>配置_config.yml文件</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> git@github.com:Saln137/Saln137.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo c</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br><br></code></pre></td></tr></table></figure><h3 id="Typora图片设置"><a href="#Typora图片设置" class="headerlink" title="Typora图片设置"></a>Typora图片设置</h3><img src="/post/14fc6d5d/image-20221008191910405.png" class="" title="image-20221008191910405"><h3 id="Typora上传图片至腾讯云COS"><a href="#Typora上传图片至腾讯云COS" class="headerlink" title="Typora上传图片至腾讯云COS"></a>Typora上传图片至腾讯云COS</h3><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082100754.png" alt="image-20221008210045938"></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 写作</title>
    <link href="/post/3917aff.html"/>
    <url>/post/3917aff.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><h3 id="生成markdown文件"><a href="#生成markdown文件" class="headerlink" title="生成markdown文件"></a>生成markdown文件</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> <span class="hljs-string">&quot;post title&quot;</span> <br></code></pre></td></tr></table></figure><h3 id="生成草稿页面"><a href="#生成草稿页面" class="headerlink" title="生成草稿页面"></a>生成草稿页面</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">draft</span> <span class="hljs-string">&quot;draft title&quot;</span> <br></code></pre></td></tr></table></figure><h3 id="生成网页页面"><a href="#生成网页页面" class="headerlink" title="生成网页页面"></a>生成网页页面</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> <span class="hljs-string">&quot;page title&quot;</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
