<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java面试知识点收集</title>
    <link href="/post/906095e6.html"/>
    <url>/post/906095e6.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-ConcurrentModificationException"><a href="#1-ConcurrentModificationException" class="headerlink" title="1.ConcurrentModificationException"></a>1.ConcurrentModificationException</h2><p>ConcurrentModificationException(并发修改异常)：迭代器遍历过程中，通过集合对象修改了集合中的元素长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</p><p>ConcurrentModificationException是基于java<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>中的 <strong>快速失败（fail-fast）</strong> 机制产生的，在使用<a href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020">迭代器</a>遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了增删改，就会抛出该异常。<br>快速失败机制使得java的集合类不能在<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>下并发修改，也不能在迭代过程中被修改。</p><h4 id="1-1抛异常实例"><a href="#1-1抛异常实例" class="headerlink" title="1.1抛异常实例"></a>1.1抛异常实例</h4><p>使用迭代器遍历list，同时使用list.remove方法删除元素，会抛ConcurrentModificationException异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryRemove</span><span class="hljs-params">(List&lt;String&gt; strings)</span> &#123;<br>    Iterator&lt;String&gt; it = strings.iterator();<br>    <span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> it.next();<br>        <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;remove&quot;</span>)) &#123;<br>            strings.remove(str);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2抛异常的原因"><a href="#1-2抛异常的原因" class="headerlink" title="1.2抛异常的原因"></a>1.2抛异常的原因</h4><p>抛异常是在next方法中，该方法共有两处抛异常，上面的实例中，是在next方法的第一处抛的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>    <span class="hljs-keyword">if</span> (i &gt;= limit)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>    <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    cursor = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个modCount的作用是什么呢？<br>modCount是在AbstractList抽象类中定义，且声明为<code>protected transient</code>，该变量实际就是个修改次数的计数标志，以ArrayList为例，会在ArrayList的以下方法中执行<code>modCount++</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span> &#123; ... &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123; ... &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123; ... &#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> &#123; ... &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>add方法内部会调用到ensureExplicitCapacity方法，也间接调用了modCount++。<br>这些方法的共同点：<em>变更了list的数组长度或移动了list内部的元素。只要list集合内部数组结构上发生了变更，modCount就会自增1</em>。<br>所以上面的例子中，expectedModCount值记录的是调用iterator方法时的modCount值，而调用过一次list.remove之后，modCount自增1，也就与expectedModCount不相等了，所以就抛出异常，表明在迭代过程中list被修改了而快速失败。<br>因此在使用迭代器遍历删除集合元素时，应使用迭代器的remove方法，其内部会更新expectedModCount及cursor，以避免调用next方法时抛异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    ......<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>            cursor = lastRet;<span class="hljs-comment">//更新cursor，避免next方法中的第二处抛异常</span><br>            lastRet = -<span class="hljs-number">1</span>;<br>            expectedModCount = modCount;<span class="hljs-comment">//调用remove后更新expectedModCount</span><br>            limit--;<span class="hljs-comment">//更新列表长度</span><br>        &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        &#125;<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3如何避免此异常"><a href="#1-3如何避免此异常" class="headerlink" title="1.3如何避免此异常"></a>1.3如何避免此异常</h4><p>modCount只在集合的内部迭代器中使用，所以规避该异常只需在使用迭代器时考虑迭代器内部的expectedModCount与list的modCount值是否相等，游标cursor是否可能大于数组长度。<br>基于此思考归纳出以下几点可能抛该异常的情景：</p><ul><li>迭代器遍历过程中，调用了集合的remove或add等改变了集合结构的方法；</li><li>foreach循环遍历集合，实际上隐式调用了迭代器遍历，同样调用集合的remove或add等方法会抛异常；</li><li>多线程环境下，迭代器遍历+iterator.remove也可能导致异常，因此多线程环境下建议使用并发集合或做好线程间的同步。</li></ul><p>使用<strong>ListIterator</strong>（list集合特有迭代器）不会发生并发修改异常</p><h2 id="2-Deque的认识"><a href="#2-Deque的认识" class="headerlink" title="2.Deque的认识"></a>2.Deque的认识</h2><p> deque容器为一个给定<em>*类型*<em>的元素进行</em>*线性处理*<em>，像向量一样，它</em>*能够快速地随机访问任一个元素*<em>，并且能够高效地</em>*插入和删除*<em>容器的尾部元素。但它又与<a href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020">vector</a>不同，</em>*deque支持高效插入和删除容器的头部元素*<em>，因此也叫做</em>*<strong>双端队列</strong>*</em></p><p>一个完善，可靠性高的LIFO栈操作由Deque接口</p><h2 id="3-hashCode的作用"><a href="#3-hashCode的作用" class="headerlink" title="3.hashCode的作用"></a>3.hashCode的作用</h2><p>以下是关于HashCode的官方文档定义：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。 <br>hashCode 的常规协定是： <br>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 <span class="hljs-keyword">equals</span> 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 <br>如果根据 <span class="hljs-keyword">equals</span>(<span class="hljs-type">Object</span>) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。 <br>以下情况不 是必需的：如果根据 <span class="hljs-keyword">equals</span>(java.lang.<span class="hljs-type">Object</span>) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。 <br>实际上，由 <span class="hljs-type">Object</span> 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） <br>当<span class="hljs-keyword">equals</span>方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。<br></code></pre></td></tr></table></figure><p>1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</p><p>2、如果两个对象相同，就是适用于<a href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a>(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</p><p>3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</p><p>4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们<strong>“存放在同一个篮子里”</strong>。</p><h2 id="4-为什么重写equals方法，还必须要重写hashcode方法"><a href="#4-为什么重写equals方法，还必须要重写hashcode方法" class="headerlink" title="4.为什么重写equals方法，还必须要重写hashcode方法"></a>4.为什么重写equals方法，还必须要重写hashcode方法</h2><p>为了提高效率，采取<a href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%86%99&spm=1001.2101.3001.7020">重写</a>hashcode方法，先进行hashcode比较，如果不同，那么就没必要在进行equals的比较了，这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的，一个很好的例子就是在集合中的使用；</p><p>我们都知道java中的List<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>是有序的，因此是可以重复的，而set集合是无序的，因此是不能重复的，那么怎么能保证不能被放入重复的元素呢，但靠equals方法一样比较的话，如果原来集合中以后又10000个元素了，那么放入10001个元素，难道要将前面的所有元素都进行比较，看看是否有重复，这个效率可想而知，因此hashcode就应遇而生了，java就采用了hash表，利用哈希算法（也叫散列算法），就是将对象数据根据该对象的特征使用特定的算法将其定义到一个地址上，那么在后面定义进来的数据只要看对应的hashcode地址上是否有值，那么就用equals比较，如果没有则直接插入，只要就大大减少了equals的使用次数，执行效率就大大提高了。</p><p>同时也是为了保证同一个对象，保证在<a href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a>相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode确实不相同的。</p><p>总结来说就是两点</p><p><strong>1.使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率</strong></p><p><strong>2.保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</strong></p><p><strong>小总结：</strong></p><ul><li>hashCode主要用于提升查询效率，来确定在散列结构中对象的存储地址；</li><li>重写equals()必须重写hashCode()，二者参与计算的自身属性字段应该相同；</li><li>hash类型的存储结构，添加元素重复性校验的标准就是先取hashCode值，后判断equals()；</li><li>equals()相等的两个对象，hashcode()一定相等；</li><li>反过来：hashcode()不等，一定能推出equals()也不等；</li><li>hashcode()相等，equals()可能相等，也可能不等。</li></ul><h2 id="5-ArrayList扩容机制"><a href="#5-ArrayList扩容机制" class="headerlink" title="5.ArrayList扩容机制"></a>5.ArrayList扩容机制</h2><p>一.<a href="https://so.csdn.net/so/search?q=ArrayList&spm=1001.2101.3001.7020">ArrayList</a>继承了AbstractList，实现了List接口，底层实现基于数组，因此可以认为是一个可变长度的数组。<br>二.在讲扩容机制之前，我们需要了解一下ArrayList中最主要的几个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个空数组以供使用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">//也是一个空数组，跟上边的空数组不同之处在于，这个是在默认构造器时返回的，扩容时需要用到这个作判断，后面会讲到</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">//存放数组中的元素，注意此变量是transient修饰的，不参与序列化</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-comment">//数组的长度，此参数是数组中实际的参数，区别于elementData.length，后边会说到</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><p>三.ArrayList有三个构造函数，不同的构造函数会影响后边的扩容机制判断<br>1.默认的无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，调用此构造函数，返回了一个空的数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，此数组长度为0.<br>2.给定初始容量的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑很简单，就是构造一个具有指定长度的空数组，当initialCapacity为0时，返回EMPTY_ELEMENTDATA<br>3.包含特定集合元素的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把传入的集合转换为数组，然后通过Arrays.copyOf方法把集合中的元素拷贝到elementData中。同样，若传入的集合长度为0，返回EMPTY_ELEMENTDATA<br>四.扩容机制<br>扩容开始于集合添加元素方法，添加元素有两种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    rangeCheckForAdd(index);<br><br>   ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到两个方法都调用了ensureCapacityInternal(size + 1)方法，把数组长度加1以确保能存下下一个数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法会先调用calculateCapacity方法，此时minCapacity为1，即size+1，因为初始时size为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点来了，此方法会判断当前数组是否为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，之前就强调了无参构造时才会返回这个数组。所以，若创建ArrayList时调用的是无参构造，此方法会返回DEFAULT_CAPACITY（值为10）和minCapacity的最大值，因此，最终会返回固定值10；若创建ArrayList时调用了有参构造，则此方法会返回1，注意这个<br>minCapacity变量只是第一次调用add方法时值为1，此后的调用需要根据实际的数组长度size+1。<br>然后调用ensureExplicitCapacity方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>modCount++用到了快速失败机制，此处先不做讨论。<br>如果minCapacity大于elementData.length,则会调用grow方法，注意，这个elementData.length返回的是当前数组的容量，而不是数组实际的长度size。如果调用了有参构造，例如传入的容量为5，则此时elementData.length值即为5，而此时第一次调用add时，size值为0，因此minCapacity为1，不满足条件，此情况不需要扩容调用grow方法；如果调用了无参构造返回数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，注意这个数组只是一个空数组，因此此时elementData.length为0，满足条件，需要扩容调用grow方法。<br>可能说的太啰嗦，通俗来讲，就是如果ArrayList给定了特定初始容量，则此处需要根据实际情况确定是否调用grow方法，即有可能不需要扩容。如果没有指定初始容量，第一次调用add则此处一定需要调用grow方法。<br>那么，下面就看grow方法都做了哪些处理吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)此行代码即为扩容的核心，oldCapacity为原来的容量，右移一位，即除以2，因此这句的意思就是新的容量newCapacity=oldCapacity+oldCapacity /2，即原来的1.5倍。<br>然后判断newCapacity如果小于传入的minCapacity，则直接让newCapacity等于minCapacity，即不需要扩容计算（当无参构造时，elementData.length为0，所以oldCapacity也为0，minCapacity为10，因此最终newCapacity为10）。<br>然后判断newCapacity是否大于设定的MAX_ARRAY_SIZE，此处<br><a href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a> static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;<br>如果大于，则调用hugeCapacity方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>        MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果minCapacity大于MAX_ARRAY_SIZE，则返回Integer的最大值，否则返回MAX_ARRAY_SIZE<br>最后，通过Arrays.copyOf方法把原数组的内容放到更大容量的数组里面。</p><h2 id="6-Comparable和Comparator区别"><a href="#6-Comparable和Comparator区别" class="headerlink" title="6.Comparable和Comparator区别"></a>6.Comparable和Comparator区别</h2><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//必须实现的方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br>    <span class="hljs-comment">//选择实现</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p><em>为什么可以不实现 equals(Object obj) 函数呢？ 因为任何类，默认都是已经实现了equals(Object obj)的。 Java中的一切类都是继承于java.lang.Object，在Object.java中实现了equals(Object obj)函数；所以，其它所有的类也相当于都实现了该函数。</em></p><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>两者都是用来用作对象之间的比较，都可以自定义比较规则；</li><li>两者都是返回一个描述对象之间关系的int；</li></ol><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li>comparable 在java.lang包下，comparator在java.util包下；</li><li>实现comparable 必须重写compareTo(T o)，实现comparator必须重写compare(T o1,T o2);</li><li><strong>comparable是内在比较器</strong>，表示这个类的对象直接可以相互比较this.compareTo(this)，该类支持排序，这个类对象组成的集合就可以直接使用Collections.sort方法排序，此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。<strong>comparator是外在比较器</strong>，如果想比较两个类又没有实现comparable或者想实现比较排序的，可以用Comparator.compara(o1,o2);</li><li>comparator 是典型的策略模式（策略模式指定义一组算法类，将每个算法实现封装起来，让他们可以相互替换，不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。）每个类都可以实现comparator，都可以实现比较排序；</li><li>Comparator与Comparable同时存在的情况下，<strong>比较器Comparator优先级高。</strong></li><li>使用Comparable需要修改原先的实体类，是属于一种自然排序，而Comparator 是不用修改原先的类的实现一个新的比较器 。Comparator实际应用广</li></ol><h2 id="7-单例模式"><a href="#7-单例模式" class="headerlink" title="7.单例模式"></a>7.单例模式</h2><h3 id="7-1-什么是单例模式"><a href="#7-1-什么是单例模式" class="headerlink" title="7.1. 什么是单例模式"></a>7.1. 什么是单例模式</h3><p><strong>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。</strong>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTE1MTI2Njk4LTg5NmU2NDQzLTBmOWUtNGM4Yy1iNGEwLWJiMDRjOWUxY2I2ZC5wbmc?x-oss-process=image/format,png" alt="image.png"></p><h3 id="7-2-单例模式的类型"><a href="#7-2-单例模式的类型" class="headerlink" title="7.2. 单例模式的类型"></a>7.2. 单例模式的类型</h3><p>单例模式有两种类型：</p><ul><li>懒汉式：在<strong>真正需要使用</strong>对象时才去创建该单例类对象</li><li>饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，等待被程序使用</li></ul><h4 id="7-2-1-懒汉式创建单例对象"><a href="#7-2-1-懒汉式创建单例对象" class="headerlink" title="7.2.1 懒汉式创建单例对象"></a>7.2.1 懒汉式创建单例对象</h4><p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化<strong>（判空），</strong>若已实例化直接返回该类对象。，否则则先执行实例化操作。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTE1NTM5MjI2LWViODdmMGUxLTE2MjAtNGFmYy1iMTQwLWEzZGZiMGIxNmRjYy5wbmc?x-oss-process=image/format,png" alt="image.png"></p><p>根据上面的流程图，就可以写出下面的这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-2-2饿汉式创建单例对象"><a href="#7-2-2饿汉式创建单例对象" class="headerlink" title="7.2.2饿汉式创建单例对象"></a>7.2.2饿汉式创建单例对象</h4><p>饿汉式在<strong>类加载</strong>时已经创建好该对象，在程序调用时<strong>直接返回</strong>该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，<strong>不需要等到被调用时再去创****建</strong>。</p><p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTE4NjM2NTgyLTYzN2RjZjZhLTgwOTEtNDBkNC05YWNjLTQ2ZmFjYTllM2NkMi5wbmc?x-oss-process=image/format,png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意上面的代码在第3行已经实例化好了一个Singleton对象在内存中，不会有多个Singleton对象实例存在，类在加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡了。</p><h3 id="7-3-懒汉式如何保证只创建一个对象"><a href="#7-3-懒汉式如何保证只创建一个对象" class="headerlink" title="7.3. 懒汉式如何保证只创建一个对象"></a>7.3. 懒汉式如何保证只创建一个对象</h3><p>我们再来回顾懒汉式的核心方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>        singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法其实是存在问题的，试想一下，如果两个线程同时判断singleton为空，那么它们都会去实例化一个Singleton对象，这就变成双例了。所以，我们要解决的是<strong>线程安全</strong>问题。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTIwNjkyNjU1LWUxY2MwNTM4LTE2NWYtNDYxNS05ODgwLWJiYmI3YTFmOTJhOC5wbmc?x-oss-process=image/format,png" alt="image.png"></p><p>最容易想到的解决方法就是在方法上加锁，或者是对类对象加锁，程序就会变成下面这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>        singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;   <br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：<strong>每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</strong></p><p>接下来要做的就是<strong>优化性能，目标是：</strong>如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</p><p><strong>所以直接在方法上加锁的方式就被废掉了，因为这种方式无论如何都需要先获取锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>       <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>            <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码已经完美地解决了<strong>并发安全+性能低效</strong>问题：</p><ul><li>第2行代码，如果singleton不为空，则直接返回对象，不需要获取锁；而如果多个线程发现singleton为空，则进入分支；</li><li>第3行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton是否为空，因为singleton有可能已经被之前的线程实例化</li><li>其它之后获取到锁的线程在执行到第4行校验代码，发现singleton已经不为空了，则不会再new一个对象，直接返回对象即可</li><li>之后所有进入该方法的线程都不会去获取锁，在第一次判断singleton对象时已经不为空了</li></ul><p>因为需要两次判空，且对类对象加锁，该懒汉式写法也被称为：<strong>Double Check（双重校验） + Lock（加锁）</strong></p><p>完整的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>       singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码已经近似完美了，但是还存在最后一个问题：指令重排</p><h3 id="7-4-使用volatile防止指令重排"><a href="#7-4-使用volatile防止指令重排" class="headerlink" title="7.4. 使用volatile防止指令重排"></a>7.4. 使用volatile防止指令重排</h3><p>创建一个对象，在JVM中会经过三步：</p><p>（1）为singleton分配内存空间</p><p>（2）初始化singleton对象</p><p>（3）将singleton指向分配好的内存空间</p><p>指令重排序是指：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p><p>在这三步中，第2、3步有可能会发生指令重排现象，创建对象的顺序变为1-3-2，会导致多个线程获取对象时，有可能线程A创建对象的过程中，执行了1、3步骤，线程B判断singleton已经不为空，获取到未初始化的singleton对象，就会报NPE异常。文字较为晦涩，可以看流程图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTIyMzkwNzk3LTRkZjBkMDA4LTM3MmMtNDkxZi04YjlhLWY4NjBmODAzNzFhYi5wbmc?x-oss-process=image/format,png" alt="image.png"></p><p>使用volatile关键字可以<strong>防止指令重排序，</strong>其原理较为复杂，这篇博客不打算展开，可以这样理解：<strong>使用volatile关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换</strong>，这样在多线程环境下就不会发生NPE异常了。</p><blockquote><p>volatile还有第二个作用：使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，<strong>线程每次操作该变量都需要先读取该变量。</strong></p></blockquote><p>最终的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 线程A或线程B获得该锁进行初始化</span><br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span><br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-5-破坏懒汉式单例与饿汉式单例"><a href="#7-5-破坏懒汉式单例与饿汉式单例" class="headerlink" title="7.5. 破坏懒汉式单例与饿汉式单例"></a>7.5. 破坏懒汉式单例与饿汉式单例</h3><p>无论是完美的懒汉式还是饿汉式，终究敌不过<strong>反射和序列化</strong>，它们俩都可以把单例对象破坏掉（产生多个对象）。</p><h5 id="1：演示利用反射破坏单例模式"><a href="#1：演示利用反射破坏单例模式" class="headerlink" title="1：演示利用反射破坏单例模式"></a>1：演示利用<strong>反射</strong>破坏单例模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 获取类的显式构造器</span><br>    Constructor&lt;Singleton&gt; construct = Singleton.class.getDeclaredConstructor();<br>    <span class="hljs-comment">// 可访问私有构造器</span><br>    construct.setAccessible(<span class="hljs-literal">true</span>); <br>    <span class="hljs-comment">// 利用反射构造新对象</span><br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> construct.newInstance(); <br>    <span class="hljs-comment">// 通过正常方式获取单例对象</span><br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> Singleton.getInstance(); <br>    System.out.println(obj1 == obj2); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述的代码一针见血了：利用反射，强制访问类的私有构造器，去创建另一个对象</p><h5 id="2：利用序列化与反序列化破坏单例模式"><a href="#2：利用序列化与反序列化破坏单例模式" class="headerlink" title="2：利用序列化与反序列化破坏单例模式"></a>2：利用<strong>序列化与反序列化</strong>破坏单例模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 创建输出流</span><br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Singleton.file&quot;</span>));<br>    <span class="hljs-comment">// 将单例对象写到文件中</span><br>    oos.writeObject(Singleton.getInstance());<br>    <span class="hljs-comment">// 从文件中读取单例对象</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Singleton.file&quot;</span>);<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file));<br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> (Singleton) ois.readObject();<br>    <span class="hljs-comment">// 判断是否是同一个对象</span><br>    System.out.println(newInstance == Singleton.getInstance()); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>两个对象地址不相等的原因是：readObject() 方法读入对象时，<strong>它必定会返回一个新的对象实例</strong>，必然指向新的内存地址。</p><h3 id="7-6-枚举实现"><a href="#7-6-枚举实现" class="headerlink" title="7.6.枚举实现"></a>7.6.枚举实现</h3><p>在 JDK1.5 后，使用 Java 语言实现单例模式的方式又多了一种：<strong>枚举</strong></p><p>我们先来看看枚举如何实现单例模式的，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是枚举类型的单例模式！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要思考：<strong>使用枚举实现单例模式的优势在哪里？</strong></p><p><strong>优势1</strong>：代码对比饿汉式与懒汉式来说，更加地简洁; 其次，既然是实现单例模式，那这种写法<strong>必定满足单例模式</strong>的要求，而且使用枚举实现时，没有做任何额外的处理。</p><p><strong>优势2</strong>：它不需要做任何额外的操作去保证对象单一性与线程安全性</p><p>我写了一段测试代码放在下面，这一段代码可以<strong>证明程序启动时仅会创建一个 Singleton 对象</strong>，且是线程安全的。</p><blockquote><p>我们可以简单地理解枚举实现单例的过程：<strong>在程序启动时，会调用Singleton的空参构造器，实例化好一个Singleton对象赋给INSTANCE，之后再也不会实例化</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    Singleton() &#123; System.out.println(<span class="hljs-string">&quot;枚举创建对象了&quot;</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-comment">/* test(); */</span> &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> Singleton.INSTANCE;<br>        System.out.print(<span class="hljs-string">&quot;t1和t2的地址是否相同：&quot;</span> + t1 == t2);<br>    &#125;<br>&#125;       <br><span class="hljs-comment">// 枚举创建对象了</span><br><span class="hljs-comment">// t1和t2的地址是否相同：true</span><br></code></pre></td></tr></table></figure><p><strong>优势3</strong>：使用枚举可以防止调用者使用<strong>反射</strong>、<strong>序列化与反序列化</strong>机制强制生成多个单例对象，破坏单例模式。</p><p>防破坏的原理如下：</p><p><strong>（1）防反射</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk1MDg0MzI2NDM4LTgxYTkwNTdiLTIwZmItNDMyOS04NDU5LWRkYjJlY2NiMGQ0NS5wbmc?x-oss-process=image/format,png" alt="image-20200718213354831.png"></p><p>枚举类默认继承了 Enum 类，在利用反射调用 newInstance() 时，会判断该类是否是一个枚举类，如果是，则抛出异常。</p><p><strong>（2）防止反序列化创建多个枚举对象</strong></p><p>在读入Singleton对象时，每个枚举类型和枚举名字都是唯一的，所以在序列化时，仅仅只是对枚举的<strong>类型和变量名</strong>输出到文件中，在读入文件反序列化成对象时，<strong>利用 Enum 类的 valueOf(String name) 方法</strong>根据变量的名字查找对应的枚举对象。</p><p>所以，在序列化和反序列化的过程中，只是写出和读入了<strong>枚举类型和名字</strong>，没有任何关于对象的操作。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk1MDg0MzY4MDE5LWQ2NzUzNzg1LWM0ZWMtNGI4MC05ODFlLWEzNzFjOWJlNDE5Yy5wbmc?x-oss-process=image/format,png" alt="image-20200718224707754.png"></p><p>小总结：</p><p>（1）Enum 类内部使用<strong>Enum 类型判定</strong>防止通过反射创建多个对象</p><p>（2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），<strong>通过 valueOf() 方法匹配枚举名</strong>找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</p><p>（3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与<strong>饿汉式单例有异曲同工之妙</strong>。</p><h3 id="7-7-总结"><a href="#7-7-总结" class="headerlink" title="7.7.总结"></a>7.7.总结</h3><p>（1）单例模式常见的写法有两种：<strong>懒汉式、饿汉式</strong></p><p>（2）懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：<strong>Double Check + Lock</strong>，解决了并发安全和性能低下问题</p><p>（3）饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</p><p>（4）在开发中如果对<strong>内存要求非常高</strong>，那么使用懒汉式写法，可以在特定时候才创建该对象；</p><p>（5）如果对内存要求不高使用饿汉式写法，因为<strong>简单不易出错</strong>，且没有任何并发安全和性能问题</p><p>（6）为了防止多线程环境下，因为指令重排序导致变量报NPE，<strong>需要在单例对象上添加volatile关键字防止指令重排序</strong></p><p>（7）最优雅的实现方式是使用<strong>枚举</strong>，其代码精简，没有线程安全问题，且 Enum 类内部<strong>防止反射和反序列化时破坏单例</strong>。</p><h2 id="8-Spring-AOP和Spring-IOC"><a href="#8-Spring-AOP和Spring-IOC" class="headerlink" title="8.Spring AOP和Spring IOC"></a>8.Spring AOP和Spring IOC</h2><h3 id="8-1-Spring-AOP"><a href="#8-1-Spring-AOP" class="headerlink" title="8.1 Spring AOP"></a>8.1 Spring AOP</h3><p>AOP（Aspect Oriented Programming），面向切面编程，通过预编译方式和运行期动态代理实现程序功能，AOP可是说是OOP的延续，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的复用性，提高开发效率。AOP底层是通过Spring提供的动态代理技术实现的，在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，再去调用目标对象的方法，从而完成功能的增强</p><h2 id="9-浏览器输入域名后发生"><a href="#9-浏览器输入域名后发生" class="headerlink" title="9.浏览器输入域名后发生"></a>9.浏览器输入域名后发生</h2><p>1.DNS解析</p><p>2.建立TCP连接</p><p>3.发送HTTP请求</p><p>4.服务器解析请求</p><p>5.返回HTTP响应</p><p>6.TCP四次挥手</p><p>7.浏览器解析HTML</p><h2 id="10-mysql优化"><a href="#10-mysql优化" class="headerlink" title="10.mysql优化"></a>10.mysql优化</h2><h3 id="SELECT语句-执行顺序："><a href="#SELECT语句-执行顺序：" class="headerlink" title="SELECT语句 - 执行顺序："></a>SELECT语句 - 执行顺序：</h3><blockquote><p><strong>FROM</strong><br>&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。<br><strong>ON</strong><br>&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选<br><strong>JOIN</strong> &lt;join, left join, right join…&gt;<br>&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中<br><strong>WHERE</strong><br>&lt;where条件&gt; # 对上述虚表进行筛选<br><strong>GROUP BY</strong><br>&lt;分组条件&gt; # 分组<br>&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的<br><strong>HAVING</strong><br>&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选<br><strong>SELECT</strong><br>&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外<br><strong>DISTINCT</strong><br># 数据除重<br><strong>ORDER BY</strong><br>&lt;排序条件&gt; # 排序<br><strong>LIMIT</strong><br>&lt;行数限制&gt;</p></blockquote><h3 id="不使用-Select"><a href="#不使用-Select" class="headerlink" title="不使用 Select*"></a>不使用 Select*</h3><p>使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。</p><p>建议提出业务实际需要的列数，将指定列名以取代select *</p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>执行下面sql查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,age <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>可通过普通索引列(age) 就能获取SQL所需的所有列数据，无需回表，速度更快。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> 分析:<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8815cd770955423c84e78a89dda111b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR54ix5aSn6aOO5ZKM54OI6YWS,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p> 可通过Extra 是否是Using Index 判断查询是否索引覆盖</p><p>如何实现索引覆盖: 将被查询的字段，建立到联合索引里去</p><p>哪些场景适合使用索引覆盖来优化SQL</p><ul><li>全表count查询优化 </li><li>列查询回表优化</li><li>分页查询</li></ul><h3 id="在mysql中，float和double都是浮点数类型："><a href="#在mysql中，float和double都是浮点数类型：" class="headerlink" title="在mysql中，float和double都是浮点数类型："></a>在mysql中，float和double都是<a href="https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9&spm=1001.2101.3001.7020">浮点</a>数类型：</h3><ul><li>float 占4个字节，精度是6位；</li><li>double 占8个字节，精度是16位；</li></ul><h3 id="MySQL主从复制原理"><a href="#MySQL主从复制原理" class="headerlink" title="MySQL主从复制原理"></a>MySQL主从复制原理</h3><p>MySQL的主从复制和MySQL的读写分离两者有必然的联系，首先要部署主从复制，只有主从复制完成了，才能在此基础上进行数据的读写分离</p><h4 id="1）MySQL支持的复制类型"><a href="#1）MySQL支持的复制类型" class="headerlink" title="1）MySQL支持的复制类型"></a>1）MySQL支持的复制类型</h4><p>（1）基于语句的复制：在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。但是必须开启二进制日志功能；<br>（2）基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍；<br>（3）混合类型的复制：默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制；</p><h4 id="2）复制的工作过程"><a href="#2）复制的工作过程" class="headerlink" title="2）复制的工作过程"></a>2）复制的工作过程</h4><p>MySQL复制的工作过程详细介绍：<br>1.在每个事务更新数据完成之前，Master在二进制日志记录这些变化。写入二进制日志完成后，Master通知存储引擎提交事务；<br>2.Slave将Master的Binary log（二进制日志）复制到其Relay log（中继日志）。首先Slave开始一个工作进程——I/O线程，I/O线程在Master上打开一个普通的连接，然后开始Binlog dump process（二进制日志转储过程）。Binlog dump process从Master的二进制日志中读取事件，如果已经跟上Master，它就会睡眠并等待Master产生新的事件。I/O线程将这些时间写入中继日志；<br>3.SQL slave thread（SQL从线程）处理该过程的最后一步。SQL线程从中继日志中读取事件，并重放其中的事件而更新Slave的数据，使其与Master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小；</p><p>复制过程有一个很重要的限制，即复制在Slave上是串行化的，也就是说Master上的并行更新操作不能在Slave上并行操作。<br><img src="https://img-blog.csdnimg.cn/1815452b819c404196c6736779e79ad7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2FuZG3kuLZEZW1vbg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><a href="https://so.csdn.net/so/search?q=%E7%8A%B6%E6%80%81%E7%A0%81&spm=1001.2101.3001.7020">状态码</a></h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>当用户在浏览网页的时候，浏览器会返回一个http状态码，主要是用来响应浏览器的请求。通常情况下，一般是3位数字，http状态码是由RFC 2616来定义的，所有的状态码的第一个数字就代表着是什么状态。</p><h3 id="2、状态码的分类"><a href="#2、状态码的分类" class="headerlink" title="2、状态码的分类"></a>2、状态码的分类</h3><p>1xx<br>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</p><p>2xx<br>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p><p>3xx<br>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 location 域中指明。</p><p>4xx<br>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p><p>5xx<br>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p><h3 id="3、http常用状态码有哪些"><a href="#3、http常用状态码有哪些" class="headerlink" title="3、http常用状态码有哪些"></a>3、http常用状态码有哪些</h3><p><strong>200</strong><br>HTTP 200 状态码表示请求成功，并且所发送的请求希望返回响应，如果在访问网站或者查看网站空间日志的时候，看到200则表示正常。</p><p><strong>301</strong><br>HTTP 301 状态码可能对于运维人员并不是很陌生，一般网站在进行跳转的时候，会用到301，一般情况下，由于域名到期，或者域名不去续费，进行将资源进行转移到其他的网站上，301是一种永久的重定向。</p><p><strong>302</strong><br>HTTP 302 状态码是HTTP协议中的一个状态码(Status Code)。可以简单的理解为该资源原本确实存在，但已经被临时改变了位置；换而言之，就是请求的资源暂时驻留在不同的URI下，故而除非特别指定了缓存头部指示，该状态码不可缓存。</p><p><strong>304</strong><br>如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。简单的表达就是：服务端已经执行了GET，但文件未变化。</p><p><strong>307</strong><br>307为临时重定向，如果重定向307的原请求不是get或者head方法，那么浏览器一定会自动的进行重定向，即便location有url，也应该忽略。</p><p>状态码 307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化。当响应状态码为 302 的时候，一些旧有的用户代理会错误地将请求方法转换为 GET：使用非 GET 请求方法而返回 302 状态码，Web 应用的运行状况是不可预测的；而返回 307 状态码时则是可预测的。对于 GET 请求来说，两种情况没有区别。</p><p><strong>308</strong><br>在HTTP协议中，308 Permanent Redirect(永久重定向)是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由Location首部指定的URL上。浏览器会进行重定向，同时搜索引擎也会更新其链接(用SEO的行话来说，意思是“链接汁”(linkjuice)被传递到了新的 URL)</p><p><strong>400</strong><br>HTTP 400 状态码告诉客户端它发送了一条异常请求。400页面是当用户在打开网页时，返回给用户界面带有400提示符的页面。其含义是你访问的页面域名不存在或者请求错误。主要分为两种。</p><p><strong>401</strong><br>请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。</p><p><strong>403</strong><br>服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。</p><p><strong>404</strong> 状态码<br>当用户在访问网站的时候，可能会出现404页面，出现404页面的原因可能就是请求的资源不存在，页面可能被删除。</p><p><strong>500</strong><br>HTTP 500 状态码也是最常见的一种状态码，相信很多程序员都遇到过，500表示是网站的服务器出现问题，但是不同的状态码代表服务器出现的问题不一样。</p><p><strong>501</strong><br>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</p><p><strong>503</strong><br>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算课程实验</title>
    <link href="/post/5c6b54bf.html"/>
    <url>/post/5c6b54bf.html</url>
    
    <content type="html"><![CDATA[<h1 id="配置ssh免密登录"><a href="#配置ssh免密登录" class="headerlink" title="配置ssh免密登录"></a>配置ssh免密登录</h1><p>vim /etc/hosts</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">47.103.211.80</span>node1<br><span class="hljs-number">110.40.220.94</span>node2<br><span class="hljs-number">43.139.46.197</span>node3<br></code></pre></td></tr></table></figure><p>测试三个节点是否能够ping通</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244497.png" alt="image-20221005133035326"></p><p>node1,node2,node3分别生成服务器密钥</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-keygen -t dsa -P <span class="hljs-string">&#x27;&#x27;</span> -f ~<span class="hljs-regexp">/.ssh/i</span>d_dsa<br></code></pre></td></tr></table></figure><p>分别将密钥加到authorized_keys中</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">node1:</span>cat id_dsa.pub &gt;&gt; authorized_keys<br><span class="hljs-symbol">node2:</span>cat id_dsa.pub &gt;&gt; authorized_keys1<br><span class="hljs-symbol">node3:</span>cat id_dsa.pub &gt;&gt; authorized_keys2<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244578.png" alt="image-20221006231520047"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244510.png" alt="image-20221006231539018"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244588.png" alt="image-20221006231553891"></p><p>将node2的authorized_keys1和node3的authorized_keys2分发到 node1</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">node2:</span>scp authorized_keys1 root<span class="hljs-variable">@node1</span><span class="hljs-symbol">:~/</span>.ssh/<br><span class="hljs-symbol">node3:</span>scp authorized_keys2 root<span class="hljs-variable">@node1</span><span class="hljs-symbol">:~/</span>.ssh/<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244468.png" alt="image-20221006231619407"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244006.png" alt="image-20221006231632884"></p><p>在node1中 将authorized_keys1和authorized_keys1追加到 authorized_keys中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> authorized_keys1 &gt;&gt; authorized_keys<br><span class="hljs-built_in">cat</span> authorized_keys2 &gt;&gt; authorized_keys<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244793.png" alt="image-20221006231657384"></p><p>这样node1中 就有三个节点的密钥了，将node1中的authorized_keys分发到 node2，node3</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp authorized_keys root<span class="hljs-variable">@node2</span><span class="hljs-symbol">:~/</span>.ssh/<br>scp authorized_keys root<span class="hljs-variable">@node3</span><span class="hljs-symbol">:~/</span>.ssh/<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244688.png" alt="image-20221006231720808"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244709.png" alt="image-20221006231836697"></p><p>测试：</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244400.png" alt="image-20221006231752451"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244734.png" alt="image-20221006231804027"></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244517.png" alt="image-20221006231815424"></p><h1 id="Hadoop集群搭建"><a href="#Hadoop集群搭建" class="headerlink" title="Hadoop集群搭建"></a>Hadoop集群搭建</h1><p>将Hadoop压缩包上传到Centos7中指定目录 </p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244638.png" alt="image-20221006234103045"></p><p>目录结果如下</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244553.png" alt="image-20221006234125916"></p><p>配置Java环境变量</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vim</span> hadoop-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">5</span>/etc/hadoop/hadoop-env.sh<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244497.png" alt="image-20221006234239764"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">vim core-site.<span class="hljs-keyword">xml</span> <span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244754.png" alt="image-20221006234644816"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> hdfs-site.xml<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210150244096.png" alt="image-20221006235601959"></p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔试总结</title>
    <link href="/post/429e5162.html"/>
    <url>/post/429e5162.html</url>
    
    <content type="html"><![CDATA[<h1 id="浙江保融"><a href="#浙江保融" class="headerlink" title="浙江保融"></a>浙江保融</h1><p>间接寻址</p><p>数据库语句-分组</p><p><strong>设计模式：使用设计模式取代if-else</strong></p><p><strong>跑步模拟：十个人主备就绪，号令响，十个人同时起跑</strong></p><h1 id="上海威弘"><a href="#上海威弘" class="headerlink" title="上海威弘"></a>上海威弘</h1><p>字符流</p><p>构造方法</p><p>Array List扩容</p><p>集合类继承</p><p>Thread类中方法</p><p>rabbitMQ的作用</p><p>MySQL优化建议</p><p>redis持久化和优化 </p><p>Mysql语句</p><h1 id="武汉源启"><a href="#武汉源启" class="headerlink" title="武汉源启"></a>武汉源启</h1><p>JDK和JRE的区别</p><p>join，left join，right join的区别</p><p>Java创建对象的方法</p><p>RPC，常见的RPC框架</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Waline评论系统的使用</title>
    <link href="/post/da27ec23.html"/>
    <url>/post/da27ec23.html</url>
    
    <content type="html"><![CDATA[<p>本文介绍基于**LeanCloud+Vercel **方式</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210111443690.png" alt="image-20221011144308113"></p><h1 id="LeanCloud-设置-数据库"><a href="#LeanCloud-设置-数据库" class="headerlink" title="LeanCloud 设置 (数据库)"></a>LeanCloud 设置 (数据库)</h1><ol><li><a href="https://console.leancloud.app/login">登录<em><strong>*open in new window*</strong></em></a> 或 <a href="https://console.leancloud.app/register">注册<em><strong>*open in new window*</strong></em></a> <code>LeanCloud 国际版</code> 并进入 <a href="https://console.leancloud.app/apps">控制台<em><strong>*open in new window*</strong></em></a></li><li>点击左上角 <a href="https://console.leancloud.app/apps">创建应用<em><strong>*open in new window*</strong></em></a> 并起一个你喜欢的名字 (请选择免费的开发版)</li></ol><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122207879.png" alt="image-20221012220733979"></p><p>3.<strong>进入应用，选择左下角的</strong> <code>设置</code> <strong>&gt;</strong> <code>应用 Key</code><strong>。你可以看到你的</strong> <code>APP ID</code><strong>,</strong><code>APP Key</code> <strong>和</strong> <code>Master Key</code><strong>。请记录它们，以便后续使用。</strong></p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122209209.png" alt="image-20221012220920855"></p><p>国内版需要完成备案接入</p><p>如果你正在使用 Leancloud 国内版 (<a href="https://leancloud.cn/">leancloud.cn<em><strong>*open in new window*</strong></em></a>)，我们推荐你切换到国际版 (<a href="https://leancloud.app/">leancloud.app<em><strong>*open in new window*</strong></em></a>)。否则，你需要为应用额外绑定<strong>已备案</strong>的域名，同时购买独立 IP 并完成备案接入:</p><ul><li>登录国内版并进入需要使用的应用</li><li>选择 <code>设置</code> &gt; <code>域名绑定</code> &gt; <code>API 访问域名</code> &gt; <code>绑定新域名</code> &gt; 输入域名 &gt; <code>确定</code>。</li><li>按照页面上的提示按要求在 自己的域名服务商DNS 上完成 CNAME 解析。</li></ul><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122212658.png" alt="image-20221012221200267"></p><h1 id="Vercel-部署-服务端"><a href="#Vercel-部署-服务端" class="headerlink" title="Vercel 部署 (服务端)"></a>Vercel 部署 (服务端)</h1><p><a href="https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example"><img src="https://vercel.com/button" alt="Vercel"><em><strong>*open in new window*</strong></em></a></p><ol><li><p>点击上方按钮，跳转至 Vercel 进行 Server 端部署。</p><p>注</p><p>如果你未登录的话，Vercel 会让你注册或登录，请使用 GitHub 账户进行快捷登录。</p></li><li><p>输入一个你喜欢的 Vercel 项目名称并点击 <code>Create</code> 继续:</p><p><img src="https://waline.js.org/assets/vercel-1.4e9dd7aa.png" alt="创建项目"></p></li><li><p>此时 Vercel 会基于 Waline 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。</p><p><img src="https://waline.js.org/assets/vercel-3.0918fcee.png" alt="deploy"></p><p>一两分钟后，满屏的烟花会庆祝你部署成功。此时点击 <code>Go to Dashboard</code> 可以跳转到应用的控制台。</p><p><img src="https://waline.js.org/assets/vercel-4.f7f4c12b.png" alt="deploy"></p></li><li><p>点击顶部的 <code>Settings</code> - <code>Environment Variables</code> 进入环境变量配置页，并配置三个环境变量 <code>LEAN_ID</code>, <code>LEAN_KEY</code> 和 <code>LEAN_MASTER_KEY</code> 。它们的值分别对应上一步在 LeanCloud 中获得的 <code>APP ID</code>, <code>APP KEY</code>, <code>Master Key</code>。</p><p><img src="https://waline.js.org/assets/vercel-5.3a5de7f0.png" alt="设置环境变量"></p><p>注</p><p>如果你使用 LeanCloud 国内版，请额外配置 <code>LEAN_SERVER</code> 环境变量，值为你绑定好的域名。</p></li><li><p>环境变量配置完成之后点击顶部的 <code>Deployments</code> 点击顶部最新的一次部署右侧的 <code>Redeploy</code> 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。</p><p><img src="https://waline.js.org/assets/vercel-6.c1af01b1.png" alt="redeploy"></p></li><li><p>此时会跳转到 <code>Overview</code> 界面开始部署，等待片刻后 <code>STATUS</code> 会变成 <code>Ready</code>。此时请点击 <code>Visit</code> ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122213684.png" alt="image-20221012221331250"></p></li></ol><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122214387.png" alt="image-20221012221411161"></p><h1 id="绑定域名-可选"><a href="#绑定域名-可选" class="headerlink" title="绑定域名 (可选)"></a>绑定域名 (可选)</h1><ol><li><p>点击顶部的 <code>Settings</code> - <code>Domains</code> 进入域名配置页</p></li><li><p>输入需要绑定的域名并点击 <code>Add</code></p><p><img src="https://waline.js.org/assets/vercel-8.49378bd3.png" alt="Add domain"></p></li><li><p>在域名服务器商处添加新的 <code>CNAME</code> 解析记录</p><table><thead><tr><th>Type</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>CNAME</td><td>example</td><td>cname.vercel-dns.com</td></tr></tbody></table></li><li><p>等待生效，你可以通过自己的域名来访问了🎉</p><ul><li>评论系统：example.yourdomain.com</li><li>评论管理：example.yourdomain.com/ui</li></ul><p><img src="https://waline.js.org/assets/vercel-9.a29236ac.png" alt="success"></p></li></ol><h1 id="hexo-fluid主题引入Waline"><a href="#hexo-fluid主题引入Waline" class="headerlink" title="hexo-fluid主题引入Waline"></a>hexo-fluid主题引入Waline</h1><p>主题配置文件_config.yml中修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugin</span><br><span class="hljs-attr">comments:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">waline</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Waline</span><br><span class="hljs-comment"># 从 Valine 衍生而来，额外增加了服务端和多种功能</span><br><span class="hljs-comment"># Derived from Valine, with self-hosted service and new features</span><br><span class="hljs-comment"># See: https://waline.js.org/</span><br><span class="hljs-attr">waline:</span><br>  <span class="hljs-attr">serverURL:</span> <span class="hljs-string">&#x27;自己的评论地址，即上面部署成功后可跳转的那个链接&#x27;</span> <br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">highlighter:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">requiredMeta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>]<br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  <span class="hljs-attr">emoji:</span> [<span class="hljs-string">&#x27;https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo&#x27;</span>]<br>  <span class="hljs-attr">dark:</span> <span class="hljs-string">&#x27;html[data-user-color-scheme=&quot;dark&quot;]&#x27;</span><br>  <span class="hljs-attr">wordLimit:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">6</span><br>  <span class="hljs-attr">pageview:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>修改fluid\themes\fluid\layout_partials\comments\waline.ejs文件</p><p><strong>在顶部添加</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 你需要自行修改替换 `v2` 为你想要的版本号 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@waline/client@v2.13.0/dist/waline.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改server URL</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122221742.png" alt="image-20221012222154433"></p><p>完整的fluid\themes\fluid\layout_partials\comments\waline.ejs文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 你需要自行修改替换 <span class="hljs-string">`v2`</span> 为你想要的版本号 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@waline/client@v2.13.0/dist/waline.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>&lt;% <span class="hljs-keyword">if</span> (theme.<span class="hljs-property">waline</span>.<span class="hljs-property">serverURL</span>) &#123; %&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;waline&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">loadComments</span>(<span class="hljs-string">&#x27;#waline&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">createCssLink</span>(<span class="hljs-string">&#x27;&lt;%= url_join(theme.static_prefix.waline, &#x27;</span>waline.<span class="hljs-property">min</span>.<span class="hljs-property">css</span><span class="hljs-string">&#x27;) %&gt;&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">createScript</span>(<span class="hljs-string">&#x27;&lt;%= url_join(theme.static_prefix.waline, &#x27;</span>waline.<span class="hljs-property">min</span>.<span class="hljs-property">js</span><span class="hljs-string">&#x27;) %&gt;&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> options = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(</span></span><br><span class="language-javascript"><span class="language-xml">          &lt;%- <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(theme.<span class="hljs-property">waline</span> || &#123;&#125;) %&gt;,</span></span><br><span class="language-javascript"><span class="language-xml">          &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#waline&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">path</span>: &lt;%= theme.<span class="hljs-property">waline</span>.<span class="hljs-property">path</span> %&gt;,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">reaction</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启反应</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">comment</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 统计评论数</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">serverURL</span>: <span class="hljs-string">&#x27;自己url&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">          &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        )</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">Waline</span>.<span class="hljs-title function_">init</span>(options);</span></span><br><span class="language-javascript"><span class="language-xml">        </span></span><br><span class="language-javascript"><span class="language-xml">        wa_ccc = <span class="hljs-string">&quot;waline-comment-count-container&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">var</span> i=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(wa_ccc)</span></span><br><span class="language-javascript"><span class="language-xml">        i.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;inline&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">waitElementVisible</span>(<span class="hljs-string">&#x27;#waline .vcontent&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">var</span> imgSelector = <span class="hljs-string">&#x27;#waline .vcontent img:not(.vemoji)&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">imageCaption</span>(imgSelector);</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-title class_">Fluid</span>.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">fancyBox</span>(imgSelector);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>Please enable JavaScript to view the comments<span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span></span><br>&lt;% &#125; %&gt;<br><br><br></code></pre></td></tr></table></figure><p>重新部署</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><p>成功样式</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122223116.png" alt="image-20221012222347658"></p><h1 id="配置邮箱提示"><a href="#配置邮箱提示" class="headerlink" title="配置邮箱提示"></a>配置邮箱提示</h1><p>当网站有用户发布评论或者用户回复评论时，Waline 支持对博主和回复评论作者进行通知。</p><ul><li>博主通知支持多种方式，包括 QQ、微信、邮件等。</li><li>当访客的评论收到回复时，我们会对访客进行邮件通知。</li></ul><h2 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a><a href="https://waline.js.org/guide/server/notification.html">邮件通知</a></h2><p>邮件通知需要配置以下环境变量:</p><ul><li><p><code>SMTP_SERVICE</code>: SMTP 邮件发送服务提供商,例如：QQ。</p><p>提示</p><p>你可以在 <a href="https://github.com/nodemailer/nodemailer/blob/master/lib/well-known/services.json">这里<em><strong>*open in new window*</strong></em></a> 查看所有支持的运营商。</p><p>如果你的运营商不受支持，你必须填写 <code>SMTP_HOST</code> 和 <code>SMTP_PORT</code>。</p><ul><li><code>SMTP_HOST</code>: SMTP 服务器地址，一般可以在邮箱的设置中找到。</li><li><code>SMTP_PORT</code>: SMTP 服务器端口，一般可以在邮箱的设置中找到。</li></ul></li><li><p><code>SMTP_USER</code>: SMTP 邮件发送服务的用户名，一般为登录邮箱。</p></li><li><p><code>SMTP_PASS</code>: SMTP 邮件发送服务的密码，一般为邮箱登录密码，部分邮箱(例如 163)是单独的 SMTP 密码。</p></li><li><p><code>SMTP_SECURE</code>: 是否使用 SSL 连接 SMTP。</p></li><li><p><code>SITE_NAME</code>: 网站名称，用于在消息中显示。</p></li><li><p><code>SITE_URL</code>: 网站地址，用于在消息中显示。</p></li><li><p><code>AUTHOR_EMAIL</code>: 博主邮箱，用来接收新评论通知。如果是博主发布的评论则不进行提醒通知。</p></li></ul><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210122230877.png" alt="image-20221012223007629"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://waline.js.org/guide/get-started.html">Waline官方教程</a></p></li><li><p><a href="https://blog.csdn.net/qq_39788788/article/details/125708517?ops_request_misc=&request_id=&biz_id=102&utm_term=Waline%E8%AF%84%E8%AE%BA%E6%8C%82%E4%BB%B6&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-125708517.142%5Ev53%5Econtrol,201%5Ev3%5Econtrol_1&spm=1018.2226.3001.4187">Next主题增加Waline评论系统</a></p></li><li><p><a href="https://www.zywvvd.com/">https://www.zywvvd.com/</a></p></li><li><p><a href="http://minghuijia.cn/2022/03/14/Hexo-fluid%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E7%BB%9F%E8%AE%A1%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E9%87%8F/"><strong>Hexo-fluid主题设置统计博客阅读量与评论</strong></a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pdf查看</title>
    <link href="/post/48a0f817.html"/>
    <url>/post/48a0f817.html</url>
    
    <content type="html"><![CDATA[<h1 id="此种方法只支持pc显示"><a href="#此种方法只支持pc显示" class="headerlink" title="此种方法只支持pc显示"></a>此种方法只支持pc显示</h1><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&#123;% pdf &#x27;https://pdf<span class="hljs-number">-1310995062</span>.cos.ap-nanjing.myqcloud.com/SpringBoot<span class="hljs-variable">%E5</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%AC</span><span class="hljs-variable">%94</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%B0.pdf</span>&#x27; %&#125;<br><br></code></pre></td></tr></table></figure><div class="row">    <embed src="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="此方法不能加载pdf"><a href="#此方法不能加载pdf" class="headerlink" title="此方法不能加载pdf"></a>此方法不能加载pdf</h1><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&lt;iframe src<span class="hljs-operator">=</span>&#x27;/js/pdfjs/web/viewer.html?file<span class="hljs-operator">=</span>https://pdf<span class="hljs-number">-1310995062</span>.cos.ap-nanjing.myqcloud.com/SpringBoot<span class="hljs-variable">%E5</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%AC</span><span class="hljs-variable">%94</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%B0.pdf</span>&#x27; <br>style<span class="hljs-operator">=</span>&#x27;width:<span class="hljs-number">100</span>%<span class="hljs-comment">;height:100%&#x27;&gt;&lt;/iframe&gt;</span><br></code></pre></td></tr></table></figure><iframe src='/js/pdfjs/web/viewer.html?file=https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf' style='width:100%;height:100%'></iframe><h1 id="此方法显示区域太小"><a href="#此方法显示区域太小" class="headerlink" title="此方法显示区域太小"></a>此方法显示区域太小</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&lt;embed src=<span class="hljs-string">&quot;https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf&quot;</span> type=<span class="hljs-string">&quot;application/pdf&quot;</span> width=<span class="hljs-string">&quot;100%&quot; height=&quot;</span><span class="hljs-number">100</span>%&quot;&gt;  <br></code></pre></td></tr></table></figure><embed src="https://pdf-1310995062.cos.ap-nanjing.myqcloud.com/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf" type="application/pdf" width="100%" height="100%">  ]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker常用命令</title>
    <link href="/post/749ad7d8.html"/>
    <url>/post/749ad7d8.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span><br><br></code></pre></td></tr></table></figure><h1 id="1-Docker中文件挂载启动命令"><a href="#1-Docker中文件挂载启动命令" class="headerlink" title="1.Docker中文件挂载启动命令"></a>1.Docker中文件挂载启动命令</h1><h2 id="1-1挂载方式1—-数据卷挂载"><a href="#1-1挂载方式1—-数据卷挂载" class="headerlink" title="1.1挂载方式1—-数据卷挂载"></a>1.1挂载方式1—-数据卷挂载</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br>  --name nginx <span class="hljs-string">\</span><br>  -v html:/root/html <span class="hljs-string">\</span><br>  -p <span class="hljs-number">8081</span>:<span class="hljs-number">80</span><span class="hljs-string">\</span><br>  nginx <br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 查看html数据卷的位置</span><br>docker volume inspect html<br><span class="hljs-comment"># 进入该目录</span><br>cd <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>volumes<span class="hljs-regexp">/html/</span>_data<br><span class="hljs-comment"># 修改文件</span><br>vim index.html<br></code></pre></td></tr></table></figure><h2 id="1-2挂载方式2—-目录直接挂载"><a href="#1-2挂载方式2—-目录直接挂载" class="headerlink" title="1.2挂载方式2—-目录直接挂载"></a>1.2挂载方式2—-目录直接挂载</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run\<br>--name mysql\<br>    -e MYSQL_ROOT_PASSWORD=root\<br>    -p <span class="hljs-number">33061</span>:<span class="hljs-number">3306</span>\<br>    -v <span class="hljs-regexp">/tmp/my</span>sql<span class="hljs-regexp">/conf/</span>hmy.cnf:<span class="hljs-regexp">/etc/my</span>sql<span class="hljs-regexp">/conf.d/</span>hmy.cnf\<br>    -v <span class="hljs-regexp">/tmp/my</span>sql<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql\<br>    -d mysql<br></code></pre></td></tr></table></figure><h1 id="2-自定义Docker镜像"><a href="#2-自定义Docker镜像" class="headerlink" title="2.自定义Docker镜像"></a>2.自定义Docker镜像</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker build -<span class="hljs-keyword">tag</span> <span class="hljs-title">镜像名称:版本 .(.代表dockerfile</span>所在的目录) 名称必须是小写，不然会报以下错误<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -t javawebdemo:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> .<br></code></pre></td></tr></table></figure><p><u><strong>invalid argument “javawebDemo:1.0” for “-t, –tag” flag: invalid reference format: repository name must be lowercase</u></strong></p><p><strong><u>无效参数“javawebDemo:1.0”的“-t，——tag”标志:无效的引用格式:存储库名称必须是小写的</strong></u></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">运行：<br>docker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name web -p 8090:8090 -d javawebdemo:1.0</span><br></code></pre></td></tr></table></figure><h1 id="3-DockerCompose安装"><a href="#3-DockerCompose安装" class="headerlink" title="3.DockerCompose安装"></a>3.DockerCompose安装</h1><h2 id="3-1-下载"><a href="#3-1-下载" class="headerlink" title="3.1.下载"></a>3.1.下载</h2><p>Linux下需要通过命令下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装</span><br>curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`<span class="hljs-built_in">uname</span> -s`-`<span class="hljs-built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082209501.png" alt="image-20210417133020614"></p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h2 id="3-2-修改文件权限"><a href="#3-2-修改文件权限" class="headerlink" title="3.2.修改文件权限"></a>3.2.修改文件权限</h2><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改权限</span><br><span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h2 id="3-3-Base自动补全命令"><a href="#3-3-Base自动补全命令" class="headerlink" title="3.3.Base自动补全命令"></a>3.3.Base自动补全命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 补全命令</span><br>curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose<br></code></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h2 id="3-4-部署集群项目"><a href="#3-4-部署集群项目" class="headerlink" title="3.4.部署集群项目"></a>3.4.部署集群项目</h2><p>进入项目目录，然后运行下面的命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span><br></code></pre></td></tr></table></figure><p>撤销部署：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose down -d</span><br></code></pre></td></tr></table></figure><h1 id="4-Docker中项目部署常用命令"><a href="#4-Docker中项目部署常用命令" class="headerlink" title="4.Docker中项目部署常用命令"></a>4.Docker中项目部署常用命令</h1><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it mn bash<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul></li></ul><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="5-1-简化版镜像仓库"><a href="#5-1-简化版镜像仓库" class="headerlink" title="5.1.简化版镜像仓库"></a>5.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d \<br>    --restart=always \<br>    --name registry\<br>    -p 5000:5000 \<br>    -v registry-data:/var/lib/registry \<br>    registry<br></code></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="5-2-带有图形化界面版本"><a href="#5-2-带有图形化界面版本" class="headerlink" title="5.2.带有图形化界面版本"></a>5.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./registry-data:/var/lib/registry</span><br>  <span class="hljs-attr">ui:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">joxit/docker-registry-ui:static</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:80</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_TITLE=传智教育私有仓库</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_URL=http://registry:5000</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">registry</span><br></code></pre></td></tr></table></figure><h2 id="5-3-配置Docker信任地址"><a href="#5-3-配置Docker信任地址" class="headerlink" title="5.3.配置Docker信任地址"></a>5.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 打开要修改的文件</span><br>vi /etc/docker/daemon.json<br><span class="hljs-comment"># 添加内容：</span><br><span class="hljs-string">&quot;insecure-registries&quot;</span>:[<span class="hljs-string">&quot;http://110.40.220.94:8088&quot;</span>]<br><span class="hljs-comment"># 重加载</span><br>systemctl daemon-reload<br><span class="hljs-comment"># 重启docker</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="5-4-推送、拉取镜像"><a href="#5-4-推送、拉取镜像" class="headerlink" title="5.4.推送、拉取镜像"></a>5.4.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag nginx:latest 110.40.220.94:8088/nginx:1.0 <br></code></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 110.40.220.94:8088/nginx:1.0 <br></code></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 110.40.220.94:8088/nginx:1.0 <br></code></pre></td></tr></table></figure><h1 id="6-RabbitMQ"><a href="#6-RabbitMQ" class="headerlink" title="6.RabbitMQ"></a>6.RabbitMQ</h1><p><strong>版本需要使用management版本 的，不然没有管理界面</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_USER=root <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_PASS=root <span class="hljs-string">\</span><br> --name rabbitmq <span class="hljs-string">\</span><br> --hostname my-rabbit <span class="hljs-string">\</span><br> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> <span class="hljs-string">\</span><br> -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> <span class="hljs-string">\</span><br> -d <span class="hljs-string">\</span><br> rabbitmq:management<br></code></pre></td></tr></table></figure><h1 id="7-ElasticSearch"><a href="#7-ElasticSearch" class="headerlink" title="7.ElasticSearch"></a>7.ElasticSearch</h1><h2 id="7-1运行es"><a href="#7-1运行es" class="headerlink" title="7.1运行es"></a>7.1运行es</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d \<br>--name es \<br>    -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \<br>    -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br>    -e <span class="hljs-string">&quot;http.host=0.0.0.0&quot;</span> \<br>    -v es-data:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>data \<br>    -v es-plugins:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>plugins \<br>    -v es-logs:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>logs \<br>    --privileged \<br>    --network es-net \<br>    -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> \<br>    elasticsearch:<span class="hljs-number">8.4</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><h2 id="7-2部署kibana"><a href="#7-2部署kibana" class="headerlink" title="7.2部署kibana"></a>7.2部署kibana</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d \<br>--name kibana \<br>-e <span class="hljs-attribute">ELASTICSEARCH_HOSTS</span>=http://172.18.0.2:9200 \<br><span class="hljs-attribute">--network</span>=es-net \<br>-p 5601:5601  \<br>kibana:8.4.1<br></code></pre></td></tr></table></figure><p>控制台不能连接9200的解决办法：</p><ul><li><p>进入ES容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<br></code></pre></td></tr></table></figure></li><li><p>查看ip（docker内部局域网的ip）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/hosts<br></code></pre></td></tr></table></figure><p>我们将看到下面的内容：<br><img src="https://img-blog.csdnimg.cn/20200925134424472.png#pic_center" alt="在这里插入图片描述"></p><p>我们可以知道es容器在docker中的ip是<code>172.17.0.3</code></p></li><li><p>接下来就可以根据这个ip来创建容器啦</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it -d -e <span class="hljs-attribute">ELASTICSEARCH_URL</span>=http://172.17.0.3:9200 --name kibana -p 5601:5601 kibana<br></code></pre></td></tr></table></figure></li></ul><h2 id="7-3离线安装ik插件（推荐）"><a href="#7-3离线安装ik插件（推荐）" class="headerlink" title="7.3离线安装ik插件（推荐）"></a>7.3离线安装ik插件（推荐）</h2><h3 id="1）查看数据卷目录"><a href="#1）查看数据卷目录" class="headerlink" title="1）查看数据卷目录"></a>1）查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume inspect es-plugins<br></code></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;CreatedAt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2022-05-06T10:06:34+08:00&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Mountpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es-plugins&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;Scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code>这个目录中。</p><h3 id="2）解压缩分词器安装包"><a href="#2）解压缩分词器安装包" class="headerlink" title="2）解压缩分词器安装包"></a>2）解压缩分词器安装包</h3><p>下面我们需要把课前资料中的ik分词器解压缩，重命名为ik</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082210463.png" alt="image-20210506110249144"></p><h3 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a>3）上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data </code>：</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082210064.png" alt="image-20210506110704293"></p><h3 id="4）重启容器"><a href="#4）重启容器" class="headerlink" title="4）重启容器"></a>4）重启容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">4、重启容器</span><br>docker restart es<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看es日志</span><br>docker logs -f es<br></code></pre></td></tr></table></figure><h3 id="5）测试："><a href="#5）测试：" class="headerlink" title="5）测试："></a>5）测试：</h3><p>IK分词器包含两种模式：</p><ul><li><p><code>ik_smart</code>：最少切分</p></li><li><p><code>ik_max_word</code>：最细切分</p></li></ul><h2 id="7-4问题解决-—-gt-分词器没有挂在到plugins目录下"><a href="#7-4问题解决-—-gt-分词器没有挂在到plugins目录下" class="headerlink" title="7.4问题解决 —-&gt;分词器没有挂在到plugins目录下"></a>7.4问题解决 —-&gt;分词器没有挂在到plugins目录下</h2><p>\5. 进入<a href="https://so.csdn.net/so/search?q=docker&spm=1001.2101.3001.7020">docker</a> 安装elasticSearch 的容器 查看plugins</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<br><span class="hljs-built_in">cd</span> plugins <br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201114111732680.png#pic_center" alt="在这里插入图片描述"><br>6.查看当前的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201114111914484.png#pic_center" alt="在这里插入图片描述"><br>7.回到解压ik<a href="https://so.csdn.net/so/search?q=%E5%88%86%E8%AF%8D&spm=1001.2101.3001.7020">分词</a>器的目录，copy到容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> ik elasticsearch:/usr/share/elasticsearch/plugins<br>参数说明；elasticsearch docker容器名称<br>/usr/share/elasticsearch/plugins 容器所在的位置<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201114112021510.png#pic_center" alt="在这里插入图片描述"><br>\8. 查看plugins 是否成功</p><p><img src="https://img-blog.csdnimg.cn/20201114112239518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQ5MzEw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>9.重起elasticSearch 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart elasticseacher<br></code></pre></td></tr></table></figure><h3 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h3><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it elasticsearch /bin/bash<br></code></pre></td></tr></table></figure><p>在线下载并安装</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">./bin/elasticsearch-plugin install <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/github.com/medcl</span><span class="hljs-regexp">/elasticsearch-analysis-ik/releases</span><span class="hljs-regexp">/download/v</span>8.<span class="hljs-number">4.1</span>/elasticsearch-analysis-ik-<span class="hljs-number">8.4</span>.<span class="hljs-number">1</span>.zip<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/316924125878132d289dc7ea3bf99b70.png" alt="img"></p><p>进入plugins可以看到IK分词器已经安装成功</p><p><img src="https://img-blog.csdnimg.cn/img_convert/241af36b392cf1a09e169c5e45b5b600.png" alt="img"></p><h3 id="安装拼音分词插件"><a href="#安装拼音分词插件" class="headerlink" title="安装拼音分词插件"></a>安装拼音分词插件</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>elasticsearch-plugin install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/medcl/</span>elasticsearch-analysis-pinyin<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v8.4.1/</span>elasticsearch-analysis-pinyin-<span class="hljs-number">8.4</span>.<span class="hljs-number">1</span>.zip<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器搭建</title>
    <link href="/post/cb9cca01.html"/>
    <url>/post/cb9cca01.html</url>
    
    <content type="html"><![CDATA[<h1 id="Centos配置Java8环境"><a href="#Centos配置Java8环境" class="headerlink" title="Centos配置Java8环境"></a>Centos配置Java8环境</h1><p>卸载jdk</p><p>1、先输入java -version 查看是否安装了jdk</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">java -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>2、如果安装了，检查下安装的路径 which java（查看JDK的安装路径）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> java<br></code></pre></td></tr></table></figure><p>3、卸载 rm -rf JDK地址（卸载JDK）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">rm -rf <span class="hljs-regexp">/usr/</span>java<span class="hljs-regexp">/jdk/</span>jdk1.<span class="hljs-number">8.0</span>_65/<br></code></pre></td></tr></table></figure><p>4、vim命令编辑文件profile</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>1.上传并解压</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204956.png" alt="image-20220906220816921"></p><p>2.编辑配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>profile 并添加下列语句<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/opt/java/jdk1.8.0_211<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HIOME</span>/jre/lib/rt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar<br></code></pre></td></tr></table></figure><p>重载配置文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>查看是否配置成功</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Java-<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204503.png" alt="image-20220906221246518"></p><h1 id="Centos配置MySql"><a href="#Centos配置MySql" class="headerlink" title="Centos配置MySql"></a>Centos配置MySql</h1><p>1.上传MySQL压缩包并解压重命名</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204392.png" alt="image-20220906224442525"></p><p>2.编写配置文件</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204469.png" alt="image-20220906225518458"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># vi <span class="hljs-regexp">/etc/my</span>.cnf<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 设置mysql客户端默认字符集</span><br><span class="hljs-attribute">default-character-set</span>=utf8 <br><span class="hljs-attribute">socket</span>=/var/lib/mysql/mysql.sock<br><br>[mysqld]<br>skip-name-resolve<br><span class="hljs-comment">#设置3306端口</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">port </span>= 3306 <br><span class="hljs-attribute">socket</span>=/var/lib/mysql/mysql.sock<br><span class="hljs-comment"># 设置mysql的安装目录, 这里的目录一定要是你解压后并且改了名的目录哟..</span><br><span class="hljs-attribute">basedir</span>=/usr/local/mysql-5.5.40<br><span class="hljs-comment"># 设置mysql数据库的数据的存放目录, 这里的目录一定要是你解压后并且改了名的目录哟..</span><br><span class="hljs-attribute">datadir</span>=/usr/local/mysql-5.5.40/data<br><span class="hljs-comment"># 允许最大连接数</span><br><span class="hljs-attribute">max_connections</span>=200<br><span class="hljs-comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="hljs-attribute">character-set-server</span>=utf8<br><span class="hljs-comment"># 创建新表时将使用的默认存储引擎</span><br><span class="hljs-attribute">default-storage-engine</span>=INNODB<br><span class="hljs-attribute">lower_case_table_name</span>=1<br><span class="hljs-attribute">max_allowed_packet</span>=16M<br></code></pre></td></tr></table></figure><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204973.png" alt="image-20220907004719041"></p><h1 id="服务器配置HTTPS访问"><a href="#服务器配置HTTPS访问" class="headerlink" title="服务器配置HTTPS访问"></a>服务器配置HTTPS访问</h1><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082204050.png" alt="image-20220907161559932"></p><p>修改 <code>server.xml</code> 文件 <code>Connector</code>的属性为以下内容：                                                                                                       </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;Connector <span class="hljs-attribute">port</span>=<span class="hljs-string">&quot;443&quot;</span>  <br><span class="hljs-attribute">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span><br>    <span class="hljs-attribute">SSLEnabled</span>=<span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attribute">scheme</span>=<span class="hljs-string">&quot;https&quot;</span><br>    <span class="hljs-attribute">secure</span>=<span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attribute">keystoreFile</span>=<span class="hljs-string">&quot;/usr/*/conf/cloud.tencent.com.pfx&quot;</span> #证书保存的路径<br>    <span class="hljs-attribute">keystoreType</span>=<span class="hljs-string">&quot;PKCS12&quot;</span><br>    <span class="hljs-attribute">keystorePass</span>=<span class="hljs-string">&quot;证书密码&quot;</span>  # 请替换为 keystorePass.txt 密码文件中的内容。<br>    <span class="hljs-attribute">clientAuth</span>=<span class="hljs-string">&quot;false&quot;</span><br>    <span class="hljs-attribute">SSLProtocol</span>=<span class="hljs-string">&quot;TLSv1.1+TLSv1.2+TLSv1.3&quot;</span>   <span class="hljs-attribute">ciphers</span>=<span class="hljs-string">&quot;TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>配置文件的主要参数说明如下：</p><ul><li><strong>keystoreFile</strong>：证书文件的存放位置，可以指定绝对路径，也可以指定相对于  <CATALINA_HOME> （Tomcat 安装目录）环境变量的相对路径。如果此项没有设定，默认情况下，Tomcat  将从当前操作系统用户的用户目录下读取名为 “.keystore” 的文件。</li><li><strong>keystorePass</strong>：密码文件密码，指定 keystore 的密码。申请证书时若设置了私钥密码，请填写私钥密码；若申请证书时未设置私钥密码，请填写<code>cloud.tencent.com_tomcat</code> 文件夹中 keystorePass.txt 文件内的密码。</li><li><strong>clientAuth</strong>：如果设为 true，表示 Tomcat 要求所有的 SSL 客户出示安全证书，对 SSL 客户进行身份验证。</li></ul><h4 id="HTTP-自动跳转-HTTPS-的安全配置（可选）"><a href="#HTTP-自动跳转-HTTPS-的安全配置（可选）" class="headerlink" title="HTTP 自动跳转 HTTPS 的安全配置（可选）"></a>HTTP 自动跳转 HTTPS 的安全配置（可选）</h4><p>如果您需要将 HTTP 请求自动重定向到 HTTPS。您可以通过以下操作设置：</p><p>编辑  <code>/usr/*/conf</code> 目录下的 <code>web.xml</code> 文件，找到 </welcome-file-list> 标签。</p><p>请在结束标签 </welcome-file-list> 后面换行，并添加以下内容                                                                                                               </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">login-config</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- Authorization setting for SSL --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">auth-method</span>&gt;</span>CLIENT-CERT<span class="hljs-tag">&lt;/<span class="hljs-name">auth-method</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">realm-name</span>&gt;</span>Client Cert Users-only Area<span class="hljs-tag">&lt;/<span class="hljs-name">realm-name</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">login-config</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">security-constraint</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- Authorization setting for SSL --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">web-resource-collection</span> &gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">web-resource-name</span> &gt;</span>SSL<span class="hljs-tag">&lt;/<span class="hljs-name">web-resource-name</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">web-resource-collection</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">user-data-constraint</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">transport-guarantee</span>&gt;</span>CONFIDENTIAL<span class="hljs-tag">&lt;/<span class="hljs-name">transport-guarantee</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">user-data-constraint</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">security-constraint</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编辑 server.xml</p><p> 文件，将 redirectPort 参数修改为 SSL 的 connector 的端口，即443端口。如下所示：                                                                                  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;Connector port<span class="hljs-operator">=</span><span class="hljs-string">&quot;80&quot;</span> protocol<span class="hljs-operator">=</span><span class="hljs-string">&quot;HTTP/1.1&quot;</span><br>  connectionTimeout<span class="hljs-operator">=</span><span class="hljs-string">&quot;20000&quot;</span><br>  redirectPort<span class="hljs-operator">=</span><span class="hljs-string">&quot;443&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><blockquote><p>说明：              </p><p>此修改操作可将非 SSL 的 connector 跳转到 SSL 的 connector 中。</p></blockquote><p> 目录下执行以下命令，关闭 Tomcat 服务器。                                                                                                               </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">./shutdown.sh<br></code></pre></td></tr></table></figure><p>执行以下命令，确认配置是否存在问题。                                                                                                                   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configtest.sh<br></code></pre></td></tr></table></figure><ul><li>若存在，请您重新配置或者根据提示修改存在问题。</li><li>若不存在，请执行下一步。</li></ul><p>执行以下命令，启动 Tomcat 服务器，即可使用 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>cloud.tencent.com<br></code></pre></td></tr></table></figure><p> 进行访问。                                                                                                               </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./startup.sh<br></code></pre></td></tr></table></figure><h1 id="Tomcat配置"><a href="#Tomcat配置" class="headerlink" title="Tomcat配置"></a>Tomcat配置</h1><p>添加环境变量</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082205926.png" alt="image-20220907161959334"></p><p>配置默认访问界面</p><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082205723.png" alt="image-20220907162053091"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;Context path<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span> docBase<span class="hljs-operator">=</span><span class="hljs-string">&quot;blog/&quot;</span>  reloadable<span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span> debug<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> crossContext<span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h1 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h1><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082205629.png" alt="image-20220926122700969"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#user  nobody;</span><br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">#error_log  logs/error.log;</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;</span><br><span class="hljs-comment">#error_log  logs/error.log  info;</span><br><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><br>    <span class="hljs-comment">#access_log  logs/access.log  main;</span><br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br><br>        <span class="hljs-comment">#charset koi8-r;</span><br><br>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span><br><br>        <span class="hljs-section">location</span>  / &#123;<br>            <span class="hljs-attribute">root</span>   /work/class_manager/pc/dist;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>            <span class="hljs-comment">#开启后不会导致刷新白屏</span><br>            <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>        &#125;<br><br>        <span class="hljs-comment"># 接口访问路径，解决跨域</span><br>        <span class="hljs-section">location</span> /springbootajax/ &#123;<br>                <span class="hljs-attribute">proxy_pass</span> http://39.105.13.178:8345/springbootajax;<br>        &#125;<br><br><br>        <span class="hljs-comment">#error_page  404              /404.html;</span><br><br>        <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-section">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试知识点汇总</title>
    <link href="/post/d3309499.html"/>
    <url>/post/d3309499.html</url>
    
    <content type="html"><![CDATA[<h1 id="东软集团（武汉）有限公司"><a href="#东软集团（武汉）有限公司" class="headerlink" title="东软集团（武汉）有限公司"></a>东软集团（武汉）有限公司</h1><p>介绍一下面向对象 </p><p> 介绍一下知道的IO流 </p><p> 线程的状态 什么时候导致运行状态的改变 </p><p> 为什么要用线程池 </p><p> java集合的分类 说几个常用的集合（没说队列） </p><p> 了解JVM什么 </p><p> 了解一个对象是怎么创建的吗，创建对象的过程 </p><p> BIO NIO区别，阻塞是指什么 </p><p> 怎么定义一个spring的bean </p><p> spring里面如何配置单例 </p><p> spring怎么设置<a href="">数据</a>库的事务 </p><p> 学习的时候喜欢深入学习还是业务完成</p><p> String ， StrinBuffer， Stringbuilder</p><p> IO流</p><p> File类中的方法</p><p> 项目介绍</p><p> SpringBoot的理解</p><p> Android框架</p><p>  线程和进程</p><h1 id="腾讯云智研发"><a href="#腾讯云智研发" class="headerlink" title="腾讯云智研发"></a>腾讯云智研发</h1><p> 三次握手，四次挥手</p><p> TCP特殊报文</p><p> Linux CPU使用率</p><p> 系统调用fork</p><p> 按照文件名查找文件</p><p> 单例模式</p><p> MySQL索引覆盖</p><p> 不适用select * 的原因</p><p> Redis</p><p> 网站输入域名后回车会发生什么</p><p> HTTP协议</p><h1 id="开科支付中心"><a href="#开科支付中心" class="headerlink" title="开科支付中心"></a>开科支付中心</h1><p>  String类中常用方法</p><p>  Array List优缺点</p><p> MySQL查询什么时候走索引（索引覆盖）</p><p> MySQL中float 和 double</p><p> Sping AOP 的使用场景</p><p> Spring常用注解</p><p> Ajax前后端交互</p><p> Linux常用命令</p><p> SpringIOC</p><p> MySQL主从复制实现原理</p><p> Redis的作用，举例</p><p> Redis缓存击穿，缓存穿透，缓存雪崩</p><p> 事务的隔离级别</p><p> 脏读，幻读，不可重复读</p><p> PutMapping，GetMapping等，及使用它们的原因</p><p> 状态介绍 300 400 500</p><h1 id="湖北地信科技"><a href="#湖北地信科技" class="headerlink" title="湖北地信科技"></a>湖北地信科技</h1><p>使用Java实现拦截器</p><p>AOP-面向切面编程</p><p>docker搭建</p><p>ElasticSearch使用</p><p>百度地图API开放平台</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署常见命令</title>
    <link href="/post/1a17ef30.html"/>
    <url>/post/1a17ef30.html</url>
    
    <content type="html"><![CDATA[<h1 id="服务器部署常见命令"><a href="#服务器部署常见命令" class="headerlink" title="服务器部署常见命令"></a>服务器部署常见命令</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">nohup <span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>工程.<span class="hljs-keyword">jar </span>&amp;&gt;slan.log &amp;<br></code></pre></td></tr></table></figure><p>nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行，</p><p>当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。</p><p><strong>其它常用方法</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">netstat <span class="hljs-literal">-tunlp</span> | grep ××  查询出端口为××在运行应用的线程ip<br><span class="hljs-built_in">kill</span> <span class="hljs-literal">-9</span> ××   关闭线程ip 为 ××的应用<br><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> ××.jar 移除×× .jar 文件<br>java <span class="hljs-literal">-jar</span> NettyAPI.jar <span class="hljs-literal">-server</span>.port=<span class="hljs-number">9898</span><br></code></pre></td></tr></table></figure><p><strong>部署完成</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef| <span class="hljs-keyword">grep</span> java 查看是否部置成功<br></code></pre></td></tr></table></figure><p><strong>配至访问端口</strong></p><h4 id="rpm文件命令"><a href="#rpm文件命令" class="headerlink" title="rpm文件命令"></a>rpm文件命令</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>RPM 安装操作命令： <br><br>rpm -<span class="hljs-selector-tag">i</span> 需要安装的包文件名<br><br>举例如下：<br><br>rpm -<span class="hljs-selector-tag">i</span> example<span class="hljs-selector-class">.rpm</span> 安装 example<span class="hljs-selector-class">.rpm</span> 包； <br><br>rpm -iv example<span class="hljs-selector-class">.rpm</span> 安装 example<span class="hljs-selector-class">.rpm</span> 包并在安装过程中显示正在安装的文件信息； <br><br>rpm -ivh example<span class="hljs-selector-class">.rpm</span> 安装 example<span class="hljs-selector-class">.rpm</span> 包并在安装过程中显示正在安装的文件信息及安装进度； <br></code></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">.\startup.cmd -m standalone<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">031025375070,</span><span class="hljs-number">211905375145</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署项目至GitHub</title>
    <link href="/post/14fc6d5d.html"/>
    <url>/post/14fc6d5d.html</url>
    
    <content type="html"><![CDATA[<h3 id="配置-config-yml文件"><a href="#配置-config-yml文件" class="headerlink" title="配置_config.yml文件"></a>配置_config.yml文件</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> git@github.com:Saln137/Saln137.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo c</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br><br></code></pre></td></tr></table></figure><h3 id="Typora图片设置"><a href="#Typora图片设置" class="headerlink" title="Typora图片设置"></a>Typora图片设置</h3><img src="/post/14fc6d5d/image-20221008191910405.png" class="" title="image-20221008191910405"><h3 id="Typora上传图片至腾讯云COS"><a href="#Typora上传图片至腾讯云COS" class="headerlink" title="Typora上传图片至腾讯云COS"></a>Typora上传图片至腾讯云COS</h3><p><img src="https://blog-1310995062.cos.ap-chongqing.myqcloud.com/images202210082100754.png" alt="image-20221008210045938"></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 写作</title>
    <link href="/post/3917aff.html"/>
    <url>/post/3917aff.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><h3 id="生成markdown文件"><a href="#生成markdown文件" class="headerlink" title="生成markdown文件"></a>生成markdown文件</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> <span class="hljs-string">&quot;post title&quot;</span> <br></code></pre></td></tr></table></figure><h3 id="生成草稿页面"><a href="#生成草稿页面" class="headerlink" title="生成草稿页面"></a>生成草稿页面</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">draft</span> <span class="hljs-string">&quot;draft title&quot;</span> <br></code></pre></td></tr></table></figure><h3 id="生成网页页面"><a href="#生成网页页面" class="headerlink" title="生成网页页面"></a>生成网页页面</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> <span class="hljs-string">&quot;page title&quot;</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
